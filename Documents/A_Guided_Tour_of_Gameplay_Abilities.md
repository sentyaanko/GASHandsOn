
[A Guided Tour of Gameplay Abilities | Inside Unreal](https://www.youtube.com/watch?v=YvXvWa6vbAA) の字幕をまとめたファイル。
内容はほぼそのまま（カギカッコのつけ忘れをつけたぐらい）です。

---

```

VICTOR:
皆さん こんにちは
Inside Unrealへようこそ
毎週開催されるこのショーでは Unrealのすべてを学び 探求し 祝福します
私はホストのVictor Brodinです
今日のゲストはテクニカルライターの Michael Prinkeさんです
お帰りなさい

MICHAEL:
よろしくお願いします Victor

VICTOR:
前回はとても楽しかったです
マルチプレイヤーの基礎について 少し触れましたね
しかし今日は ゲームプレイアビリティシステムを取り上げます

MICHAEL:
はい
では ここから引き継いていいですか？

VICTOR:
はい どうぞ お願いします

MICHAEL:
わかりました
ゲームプレイアビリティシステムは 元々パラゴンの開発をサポートするために 作られたシステムです
これはその名のとおりです
これは プレイヤーがトリガーするアビリティ ほとんどはプレイヤーがトリガーするアビリティを 管理および作成するための 強力で洗練されたツールセットです
MOBAやアクションRPGなどで行う必要がある すべてのことを考えてみてください
非常にユニークな ヒーローキャラクターたちがいて 彼らは特殊な アビリティを持っています
多様なエフェクトや非常に変化に富んだ行動 各種の動作 トリガーしたいいろいろな エフェクトが伴います
それらはデータ駆動型の 属性をサポートできる 必要があります 
これにより スプレッドシートのようにデザイナーにとって 非常に使いやすい方法で微調整できます
また ハードコードされた変数や コード内のものをいじる必要がなくなります
そして これらすべてがネットワーク上で 実行できる必要があります
ゲームプレイアビリティシステムには そのようなことを準備し ゲーム内でキャラクター駆動アビリティを 用意するのをサポートするために必要な ツールがすべて揃っています
出荷するゲームをサポート できるほど堅牢ですが いくつかの注意点もあります
まず ブループリントへの 公開はデフォルトで制限されています
つまり プラグインを入手して すぐに有効にしても ブループリントにすぐには 公開されないクラスや機能が たくさんあります
基本的に ユーザーは 自分のゲームに合ったやり方で アビリティを整理するための ワークフローを自分で 定義することが求められています
たとえば キャラクターに アビリティを与える方法を 設定する必要があります
アビリティがコストに与える影響を 設定する必要があります
独自の属性セットなどを 設定する必要があります
ですから C++に入り キャラクター内でそのフレームワークを すべて設定する必要があります
そして 特定のプロジェクトやチーム そしてみんなで協力して 仕事をする方法に合った機能を C++レベルで選択的に 公開する必要があります
ということで ここではゲームプレイアビリティシステムを紹介し それをサポートするさまざまなクラス間の関係を 明確にしようと思います
しかし これは非常に 技術的な実装なので この話は必ずしも自明ではありません
今回の対象キャラクターとしては パラゴンのグレイストーンを使います
ここでもちょっと注意が必要です
このデモのグレイストーンは パラゴンでの実装と整合した形で 実装していません
このデモでは パラゴンのアビリティフレームワーク全体を 実装していません
これはゲームプレイアビリティシステムの 基本とその操作方法を示す 非常に単純化されたデモです
そして これを見ている パラゴンのファンや開発者には 申し訳ありませんが グレイストーンに設定した彼の攻撃は パラゴンでの動作のように 正確なものではありません
私がグレイストーンを選んだ理由は 彼がUnreal Engineマーケットプレイスで 無料で入手できる アセットだからです
したがって 私がここでやろうとしていることは すべて皆さんが自分で再現できます
また メレー(接近)攻撃もあります
そしてメレーアビリティをいくつか作って披露し その背後にある原理について 話したかったのです
前回ストリーム配信したときは メレーの仕組みを 知りたいというコメントがたくさんありました
そこでこれを機会に皆さんと 披露したいと思います
それはさておき まず ゲームプレイアビリティシステムの理論と ゲーム内での アビリティの整理について話しましょう
ゲーム用のアビリティシステム... 皆さんはこのようなものが必要な さまざまなゲームに取り組んでいる かもしれません
アクションRPGや ターンベースRPGなど
それは アビリティを使って それが実行しなければならない機能の すべての部分を担当している 1つのオブジェクト内に それらを含めるという考えです
プレイヤーが理解できるようにアビリティを 身に付けたいのです...
アクタがゲーム内で 行うことができるアクション...
そして やるべきことを すべてクラスにまとめたいのです
たとえば魔法をかけたり メレー攻撃したり そういったこと...
あるいは特別な攻撃を仕掛けるなど クラスとしてのゲームプレイアビリティは それらがどのように実行されるかを調整し 動きやアニメーションなど それらを所有するキャラクターの 一部を一時的に引き継いで それらの変更を1か所で行えるようにします
それらには 開始中 進行中で実行中 終了中 キャンセル中の概念があります
したがって それらを途中で中断して 停止するように指示することができます
このようなデザインパターンを採用することで 個々のアビリティの機能を 直感的に編集 反復 再利用できる形で カプセル化することができます
別の実装方法としては アビリティを ハードコードして 移動状態やさまざまなイベントセットに 機能を直接結び付け すぐにごちゃごちゃになるクモの巣コードを 作ることになります
もう1つ攻撃を追加したいと思ったら 大きなステートマシンに入り込んで新しい 列挙などを たくさん追加しなければならなくなります
ここでは アビリティを表すエンティティを作成します これは自己完結しています
何をすべきかを伝えます
アクタが行わなければならないことを すべて調整します
それが終わったらそれをキャラクターに追加し それを使用するように指示します
ですからはるかに簡単です
システムの詳細を理解するために ゲームプレイアビリティの ルーツについて話しましょう
まず話さなければならないのは 実はゲームプレイタグです
そのために これを戻します
ゲームプレイタグは ゲームプレイアビリティとは別のシステムで たしかデフォルトでEngine内にあります
プラグインのように 有効にする必要はありません
そしてそれは このような一連の階層的なタグを ラップする一種の変数です
ここでフルスクリーン表示に できるといいのですが
ご覧のようにさまざまなタグの ツリーのようなものがあり 親子のような形で整理されています
キャラクターのヘルスステートや 受けるさまざまなダメージを示す タグがたくさんあります
魔法をかけたり メレー攻撃を行ったりなど 可能なさまざまなアビリティのタグがあります
別のエネルギータイプ damageType.energy.fireや damageType.energy.iceなどを 作成したければ そのようにすることもできます
これは ゲーム内に存在しうる さまざまなタグのライブラリのようなもので 潜在的にさまざまなタイプのシステムで 使用できます
これらはすべてEngineの外でも編集できる コンフィグファイル内にあります
テキストエディタで開くだけですばやく データを入力できます
これは ゲームプレイアビリティシステム内の さまざまなものに使われます
アビリティをキャンセルできるアビリティの 種類をコントロールするために使われます
アビリティをトリガーすると 自動的にキャンセルタグを検索し 現在アクティブな他の アビリティにこのタグがある場合は それらのアビリティをキャンセルします
アビリティがアクティブな間 特定のタイプのタグを持つ 他のアビリティの発生をブロックできます
実行を許可するために キャラクターにそもそも 必要なタグを作成すること などができます
システムの他の部分でもタグの 使い方はたくさんあります これは ゲームプレイタグが 使われているものの 例にすぎません
これらはいろいろな場所で使われているので ここで簡単に紹介したかったのです
アビリティシステム自体の構造に関しては ちょっとC++に入って AbilitySystemComponentに 行く必要があります
これがデモキャラクター用の C++コードです
私が追加したコンポーネントの1つが AbilitySystemComponentです
これはアビリティの頭脳のようなものです
これには アクタに与えられた アビリティのリストが含まれます
それは アビリティを管理します
アビリティをアクティブ化する 役割を担っています
また ゲームプレイアトリビュートも含んでいます
AbilitySystemComponentの 内容の多くは ブループリントに直接公開されていません
コンポーネントをそこにアタッチすると C++で使用できます
そして 必要に応じて そこから任意の関数を呼び出し その機能を ブループリントに選択的に 公開するUFunctionを 書くことができます
たとえば ここにGrantAbilityクラスがあり それはキャラクターに与える機能を追加し ここで呼び出される 特定のInputCodeに関連付けます
現在私が実装している方法ではこれは 単なるインデックス番号です
しかし これは AbilitySystemComponentの アビリティのリストに追加されます
そして そのキャラクターが 使用できるようになります
次に このActivateAbility関数を 呼び出すと それはこのInputCodeを実行するよう 指示して それがアビリティをトリガーします
AbilitySystemComponent内で アビリティリストを操作する 方法はたくさんあります
他のActivateAbilityクラスがあるか 見てみましょう
TryActivateAbilityByClassは アビリティをアクティブ化するために 使用できる別の関数の例です
基本的には これにアビリティが属する サブクラスを与えることができ そのクラスに一致するアビリティを探して それを使おうとします
特定のタグを持つゲームプレイアビリティを 有効にするツールもあります
これは AIを書いていて AIがアクティベートする 正確なアビリティを 知ることに対処したいとは思わないが 一致するタグのセットを 持ったアビリティを見つけさせたいときに 本当に便利です
たとえば「ヒーリングアビリティを使用する」という コマンドを作りたいとします
自分自身にヒーリングアビリティを使うと それはヒーリングタグを持つアビリティを探し それをトリガーしようとします
AbilitySystemComponentの 関数の多くには それらを扱ういくつかの代替方法があります
それには入力コード タグ またはAbilitySpecHandle つまり追加した機能を追跡するために 使用するハンドルの いずれかを使用します
これらはいくつかの例です
このように リストからインデックス番号を 指定するという方法が気に入ったので このInputCodeを 使用するように設定したのです
そしてもちろん タグ付きの CancelAbility関数も公開し メレーアビリティを オフにするように指示できるようにしました
これがアビリティ管理の基本です
これらがそれを行ういくつかの方法です
しかし ここでのもう1つの大きな担当部分は ゲームプレイアトリビュートです
どこでしょう AttributeSet これです
ゲームプレイアトリビュートは基本的に 数値で 現在値とデフォルト値の 概念があります
これらは ゲームプレイエフェクトや その他のさまざまなデータ駆動型システムによる リフレクションを介してアクセスすることを 目的としています
基本的にはこれがキャラクターに 状態値を与える方法です これらは ゲームプレイアビリティでの計算に 必要なさまざまな種類の状態値に使用できます
それにはキャラクターの ヒットポイントなどに影響を 与えたい場合のキャラクターの ヘルス値などがあります
ヒット時のダメージを計算するために Strength、Endurance WeaponDamageのアトリビュートを 追加しました
またMaxHealth変数を追加しました
その理由は後で説明します しかし基本的にこれはゲームプレイ 状態値を処理する方法です
一時的な種類の状態値にも使用できます たとえば キャラクターがこのフレームで受けた ダメージ用の場所が必要な場合は それを一時的に保存する場所として ゲームプレイアトリビュートを使用できます
それを使ってそれらの ヘルス値の変化を計算したり 他のイベントをトリガーしたりします
たとえば キャラクターが ダメージを受けたときに HUDにダメージの数値を 表示させたいとします
それを使用してそのようなことをします
これらはAttributeSetに 含まれています
AttributeSetは一連のアトリビュートを ラップするために 確保されたクラスです
ここで強調したい重要な機能の1つは AttributeSetにはアトリビュートが 変化したときに発生するロジックを 処理するたにオーバーライド可能な 関数がいくつかあることです
たとえば PostGameplayEffectExecute これは ゲームプレイエフェクトで 変数を変更した後に 発生する関数です
また クエリーを実行して実際に変更された アトリビュートを確認し それに基づいて何らかの 機能を実行することもできます
これを使用して AttributeSetを所有する キャラクターのイベントを起動できます
ここでは 単にこれを使用して キャラクターの現在のヘルス値を 手動で固定して 0より小さくならず 最大ヘルス値を超えないようにしています
本当に簡単な典型的な例です
もう1つの重要な機能として AttributeSetクラスには さまざまなゲームプレイアトリビュートごとに ゲッターとセッターをすばやく定義するために 使用できるいくつかの マクロが含まれています
GAMEPLAYATTRIBUTE_VALUE_GETTERは 現在の値を返す 本当に単純なインライン関数です
必要に応じて他の場所でも 簡単に公開できます
VALUE_SETTERも同様です
そのアトリビュートの値などを 設定します
PROPERTY_GETTERは 特定のアトリビュートへの参照を取得します
ここで使用しているのは このPROPERTY_GETTERで定義される GetHealthAttributeです
AttributeSetについて 推奨したいことが1つあります
まず できればコードを使って ゲームプレイアトリビュートを 直接変更しないようにすることです
つまり AttributeSetで定義した さまざまなアトリビュートに対して SetAttributeを呼び出す 関数を大量に書いてはいけないということです
代わりにすべきことは ゲームプレイエフェクトシステムに頼ることです
これについては後で説明します
しかし これらは基本的に リフレクションを介してシステムを 操作するように設計されたオブジェクトであり ライブゲームプレイの観点から それを操作する方法を 制限します
これを行う理由は ハードコード化されたメソッドが コード内に大量に散らばってデバッグや トレースしにくくならないようにするためです
これらのアトリビュートを変更するのに ゲームプレイエフェクトを使用している場合は 何が原因で特定の変更が発生しているのか 何かが偶然に発生しているのか または何かが少しおかしいように見えるのかを 把握するのが はるかに簡単になります
個人的にお勧めするもう1つの ベストプラクティスは すべてにUAttributeSetを アタッチしないことです
AbilitySystemComponentを 持つものにアタッチします
同様に AbilitySystemComponentを すべてにアタッチしないでください
AbilitySystemComponentは トップレベルの扇動者(instigator)のような アクタにアタッチすることを目的としています
したがって Unreal Engineの ゲームプレイフレームワークを理解していれば 扇動者はすべてを所有し すべての責任を持つアクタです
通常はプレイヤーキャラクターです
発射物を発射すると 発射物には扇動者があります
そして それは通常 その発射物を発射したプレイヤーです
アビリティシステムにある概念として アビリティを使用するときに アビリティのソースと それがトリガーするエフェクトのソースがあり そしてそれがトリガーする エフェクトのターゲットが あります
そして そのソースはアビリティを所有する AbilitySystemComponentです
したがって やっていることをすべて凝縮し 何が起こっているかの責任が明確であることを 確認する最善の方法は AbilitySystemComponentを このエフェクトを トリガーする責任を 持たせたいキャラクターまたは 他のトップレベルアクタにアタッチすることです
武器などのようなものからアトリビュートを 入力したい場合は 単純に何らかの方法で武器に 変数をアタッチするだけです
あるいは武器にアタッチされている データテーブルで キャラクターと そのAttributeSetに情報を提供し 現在の武器のダメージなどを追跡するために 使いたいライブアトリビュートを入力します
そしてそれは これらの値を直接設定することが適していると 言える例外です
機器や統計値セットから あるいはレベルアップなどから あるいはセーブ状態から 何らかの初期化を行っている場合は それが直接AttributeSetに影響を 与える理由になります
これらを設定した方法に戻ると キャラクター内でAttributeSetを 宣言しています
ゲームプレイAbilitySystemComponent 自体を拡張し そこにカスタム機能を書き込むこともできます
これは単純なデモなので デフォルトのAbilitySystemComponentの ままにしておきました
そのためのゲッターを書きました
これは実際にはインターフェースを使っています
AbilitySystemComponentと 一緒に実装すべき AbilitySystemInterfaceクラスが あります
AbilitySystemComponentを 宣言し それをここに置いてアタッチする だけではいけません
このインターフェースを使用して ここでGetAbilitySystemComponent ゲッターに入力する必要があります
そうすることでインターフェース呼び出しを できるようになります
そうすると 必ずしも AbilitySystemComponentを 所有するアクタのクラスを 知る必要がなくなります
インターフェースにそれを 取得するように要求するだけで それがない場合は失敗し あればアクタにアタッチされている AbilitySystemComponentを 与えます
ということは もう少し少ないキャストで もう少し自由にできるということです
初期化という点では 移動コンポーネントのように 追加できる他のアクタコンポーネントと 同じように初期化されます
コンストラクター内にデフォルトの サブオブジェクトを作成して名前を付けます
これにより[Components(コンポーネント)]パネルに 移動したとき表示されます
Victor これまでのところはいいですか？

VICTOR:
はい
相変わらずいいペースで話しています
スクリーンシェアもうまくいっています

MICHAEL:
わかりました
それ以外にも AttributeSetからのゲッターに関連する 多数のゲッターをキャラクターに 実装しました
しかし ここではコンストラクター内で AttributeSetを初期化しません
することはできます
アトリビュートを手動で設定して 多数のデフォルト値などを 持たせることができます
しかし データテーブルにそれをさせることが できるのでする必要はないでしょう
データテーブルから 入力する方法を説明します
ただしその間に ここではBeginPlay内のヘッダーで 宣言されているAttributeSetへの ポインターを初期化します
AbilitySystemComponentが 有効である限り AbilitySystemComponentには AttributeSetを初期化する 独自の方法があります
それは自身で行います
そして 私がここでやっているのは AttributeSetへの参照を取得して それをこのポインターに適用するだけです
それが 私がこれを設定した方法です
そして これらの関数と少量のコードにより これはアビリティを追加して使用し ゲームプレイでこのAttributeSetを 参照する準備が整いました
ここでエディタに戻ります
データテーブルから初期化するように 設定する方法を 簡単にお見せしましょう
ここにグレイストーンのブループリントがあります
これはGASAbility Demo Character クラスから派生しました
このAbilitySystemComponentを クリックすると ここにこのデフォルトの 開始データリストがあります
これは基本的にデータテーブルのリストで キャラクターの アトリビュートの入力に使用できます
このドロップダウンからAttributeSetクラスを 選択する必要があります
次に データテーブルを選択する 必要があります
そしてこのデータテーブルへ 行くと複数の行があり それぞれAttributeSetの クラス名 ドット アトリビュートの名前の順に 名前が付けられています
これらは両方ともC++に現れるとおりです
これらが一致している限り この列のベース値は プラグインしたときにこれらの アトリビュートに適用されます...
複数のブループリントウィンドウが開いていると 思い続けています...
このデフォルトの開始テーブルに プラグインしたときです
もう1つ要件があります
AttributeSetで ゲームプレイアトリビュートを UPropertiesとして定義して Unreal Reflection Systemから 見えるようにする必要があります
そうすれば 認識されます
もしそれを忘れていたら 私がこのデモを作る過程で 何度かやったように... やったかもしれない と言われていますが それを忘れていると テーブルからのアトリビュート変更は 有効にならず MaxHealthは100ではなく0から 始まってしまいます
このMax Value列を使う代わりに MaxHealthを設定しているのは このデータテーブル機能の デフォルト実装がベース値だけしか 実際に適用しないためです
これの独自のバージョンを作成して 最小値と最大値を取得し ゲームプレイアトリビュートに 適用することができます
ゲームプレイアトリビュートには デフォルト値と現在値の概念があります
しかし 実際にはベース値しか見ません
そこで その回避策として 私はMaxHealthアトリビュートを 別に使っています
ええと 何を飛ばしたんでしょうか？ わかりました
このようなデータテーブルを自分で 作成するには [Miscellanous (その他)] [Data Table (データテーブル)]の順に選択します
次に Row Structureには AttributeMetaDataクラスを 選択します
クラスではなく 構造体です すみません 言い間違えました
これが このすべての アトリビュート開始データに関連する 構造体です
そしてそれをすると...
ここでは彼のヘルス値を表示していませんね
それをすると すべての状態値が入力され 計算に使用できるようになります
ゲームに必要なものに応じて これを操作するための複数の異なる 方法を設定できます
これは アトリビュートを 初期化するための1つの可能な方法です
これは 特にこの種のデモの目的には 非常に便利だと思います その程度は状況によって異なります
さて アビリティの基盤となるものについて 話してきたので 次は実際にゲームプレイアビリティそのものを 構成することについて話しましょう
デモとして まずGameplayEffectsについて 説明します
GameplayEffectsは 基本的に ゲームプレイアトリビュートを変更できるもの AbilitySystemComponentまたは そのオーナーに作用できるもの すべてのためのカプセル化されたクラスです
そうです GameplayEffects はい これです
たとえばバフのような 魔法のエフェクトのようなものですね
キャラクターに移動速度を 上げたりするバフを追加すると それはキャラクターに アタッチするゲームプレイエフェクトで その状態値の変化を移動速度に適用し ゲームプレイ中にその影響を ライブで確認できます
再生
ここには 特定の魔法を発動したときの キャラクターの再生効果があります
ゲームプレイエフェクトには 持続時間を設定したり 瞬間的に有効にしたり 無期限に適用したりすることができます
追加するだけで 手動で破棄するまでずっと残るので 非常に多くの用途に使用できます
これらのブループリントを作ることができます
デフォルトではブループリントに あまり公開されていない AbilitySystemComponentと アトリビュートとは異なり これらはブループリント内で 編集することを目的としています
そしてほとんどの場合 それを機能させるために手動で 実行やコードなどを 追加する必要はありません
さまざまなドロップダウンに代入する 一連の修飾子と計算があるだけで 指定した設定に基づいて それらが適用されます
したがって このRegenエフェクトには持続時間があります
持続時間は一定のスケーラブルな 浮動小数点値です
5秒間続きます
そして0.1秒の周期があります
そのため 0.1秒ごとにプレイヤーの 現在のヘルス値が変化します
ここにある修飾子は ヘルス値を変更するために設定したものです
これにより 定義したAttributeSet内にある 任意の変数を選択できる ことがわかります
これを公開するために 特別なことをする必要はありません
これは リフレクションを介してアクセスできます
これがAttributeSetを 使用する利点です
アクタの種類を知らなくてもかまいません
直接アクセスするために クラスの種類を知る必要はありません
AttributeSet名とアトリビュート名を 指定するだけで どれにエフェクトを 及ぼすかわかります
そして実際にそのアトリビュートを持っていれば それを変更します
[Modifier Op]は Addに設定しています
そして[Modifier Magnitude]は 1に設定されたScalable Floatです
また ダメージエフェクトがある場合は 修飾子を設定...
欲しいのは メレーダメージではありません
見たいのはダメージピックアップです
これです
これはもう1つの例です
これは瞬間的な継続時間を行います
したがって これは1回発生して終わりです
そしてこれは キャラクターのヘルス値に マイナス90の値を加えています
つまり キャラクターのヘルス値から 90を引いていることになります
開発環境では ヘルス値に直接影響を与えるのではなく ダメージを受けるという アトリビュートを使用するでしょう
これは デモ用に このアトリビュートに影響を与える ゲームプレイエフェクトの 非常に簡単な設定例です
ご覧のとおり ここにピックアップがあります
そして それに出くわしたとき バン！
ヘルス値が90減ります
そして 魔法エフェクトでは Rキーを押すと 彼は魔法をかけるアニメーションを行います
そしてインフィニティブレードから持ってきた この癒しのオーラが点灯します
そして 彼は5秒間 ヘルス値を再生します
これですべてうまくいっています
これがゲームプレイエフェクトの簡単な説明 少なくとも基本です
場合によっては キャラクターに一定の数値を適用するよりも 高度なことをする必要があります
たとえば このMeleeDamage ゲームプレイエフェクトがあります
この話をしているとき舌が回らないときは あらかじめ謝っておきます
「Gameplay」という単語が 前に付いているクラスは たくさんあるので それについて話そうとすると すぐに混乱してしまいます
ゲームプレイエフェクト ゲームプレイキュー ゲームプレイイベント
おわかりですね
ところで MeleeDamageゲームプレイエフェクトの 仕組みは...どこかな？
この下の方にある [Gameplay Effect]設定の下に 一連の実行があります
[Execute]です 独自のゲームプレイエフェクト計算を 作成できます
これらは それ自体が再利用できる カプセル化されたオブジェクトです
ご覧のとおり私は MeleeDamageExecutionという カスタムゲームプレイエフェクト計算を 作成しました
また カスタム修飾子計算を 作成することもできます
ええと ここの[Modifier Magnitude] [Custom Calculation Class]です
これにより カスタムマグニチュードが得られます
そして それは異なる種類の クラスを使用します
最終的に最も頻繁に使用する ゲームプレイエフェクト計算の2つのクラスは 次のようになります...
これは単にそのメニューを見るために 出しています
それはGameplayEffect ExecutionCalculationと GameplayMod MagnitudeCalculationです
ModMagnitudeCalculationは 単純化された計算クラスで 修飾子操作のために このような修飾子のマグニチュードとして 使用する単一の値を返すだけです
それがここに入ります
実行はより複雑で 潜在的により強力です
そしてここでC++に戻る必要があります
これに関する情報の多くは 必ずしもブループリントに公開されている わけではないので
ここにあるのが MeleeDamageExecutionクラスです
これはEffectExecution Calculationから来ています
これには 呼び出されたときに実行される Executeの実装関数があります
ここにはたくさんの定形コードがあり ゲームプレイエフェクトのソースと ゲームプレイエフェクトのターゲットに 関する情報を取得して 計算を行うために必要な属性を得るように 設計されています
そして このコメントの下にある 計算を実行します
計算は基本的に Damage掛けるAttackPower割る Enduranceです
したがってEnduranceを使って... どこかな
これらの関数を使用して さまざまなオーナーからアトリビュートを 取得します
これは WeaponDamageの定義を キャプチャして ここで設定した このローカルBaseDamage変数に 追加します
これは出力変数のようなものです
これはEnduranceのためにそれを取得し これはStrengthのために取得します
実際にそれを適用... あ まずい 何か変なことをして 実際とは違う名前を付けてしまいました
これは このAttackPowerローカル変数に 適用します
最後にここで実際に計算をします
それに最低値を設定しています
結局すべてを行ったら 最小のダメージ1を与えることができます
次に ダメージは負になるはずなので マイナス1を掛けます
足すのではなく引くものでなければなりません
そして最後にAddOutputModifierを 呼び出し それはターゲットアトリビュートに 与えたダメージを 出力することができます
これらのターゲットアトリビュートは 簡略化のためこの構造体の中で 定義されています
したがって このFMeleeDamageStaticsでは これらのさまざまな アトリビュートをすべて取得し ソースから取得するかターゲットから 取得するかを 設定しています
これには この種のことを行うために必要な アトリビュート取得関数を設定するための 非常に短いマクロがたくさんあります
AbilityDemoAttributeSetから 取得するように 指示しています
これらのCAPTUREDEFマクロを 使用して宣言されている Strengthアトリビュートを 取得するように指示しています
そして スナップショットを作成するべきか 変数のライブバージョンへの参照を 取得するべきかどうかについて trueかfalseで 指定しています
スナップショットを作成すると 変数を要求したその瞬間にある変数を 取得します
そのため この実行の最中または アビリティの実行中に何らかの理由で 変更があった場合 その変更は取り込まれません
変更前の元の値が そのまま維持されます
falseを指定すると 最新の値を使用しようとします
このように アビリティを 使っているプレイヤーからStrengthを 使用対象のターゲットからEnduranceを ソースからはDamageを得ています
そして ターゲットのヘルス値に 最終的に影響を与えているのです
実行計算を使用して 複数の異なる修飾子を一度に出力し ゲームプレイエフェクトのさまざまな機能を 一度にカプセル化して そのロジックを 非常に詳細で手が込んだものに することができます
一方 修飾子オペレーションマグニチュードは 出力する1つの値で 少し単純になります
したがって マグニチュード値のためだけに これを単純化することもできましたが これを使用して実行を披露することにしました
それを念頭に置いて このメレーダメージエフェクトがあります
それは瞬間的なものです
このカスタムDamageExecutionクラスを プラグインします
そして それを書くことで キャラクターにこのゲームプレイエフェクトが 適用されるたびに キャラクターからこれらのさまざまな変数を すべてフェッチし キャラクターのヘルス値へのダメージによって それらを一緒に 組み込むことがわかります
そしてゲームプレイエフェクトを適用すると... どこでしょう はい これです
ApplyGameplayEffectToTargetという 関数があります
また ApplyGameplayEffectToSelfを行い アビリティをトリガーする AbilitySystemComponentが 自身をターゲットとしてそれを 適用することもできます
この種の関数は どのキャラクターにどのようなエフェクトを 加えるかを指定するものです
そして 前提として ターゲットにしているのは AbilitySystemComponentであって それが属するキャラクターではないことが わかります
そのため AbilitySystemComponentへの参照を 取得するためにキャラクタークラスを 知る必要はありません
アビリティシステムのインターフェース呼び出しを 使用するだけで 任意のアクタをプラグインできます
したがって キューブから AbilitySystemComponentを 取得したい場合は それをプラグインすると コンポーネントに行って これに ゲームプレイエフェクトのターゲットとして 渡そうしようとします
これが 誰にどのエフェクトを 適用するかを指定する方法です
そして必然的に ApplyGameplayEffect ToTarget実装を行うと この最初のTargetは アビリティのユーザー つまりエフェクトのソースの 責任者を参照します
この下のTarget変数は これを適用する対象を参照します
ちょっとわかりにくいですが 基本的にはそういう仕組みです
スタンドアロンのエフェクトの例を見るために ここにピックアップを作りました
これはキャラクターがそれに触れると 爆発してダメージを与えます
これは 重なったアクタから AbilitySystemComponentを 取得しようとするだけです
アクタが何であろうとかまいません
それが何なのかは知りません
それが何なのか知りたくありません
それがAbilitySystemComponentを 持っているかどうか知りたいだけです
そして それにダメージピックアップ ゲームプレイエフェクトを適用します
それには戻り値があります
この戻り値はゲームプレイエフェクトハンドルです
したがって 何らかの理由で キャラクターに加えた エフェクトの記録を取りたい場合は このように記録を取ります
これらのさまざまなハンドルはすべて C++で渡す方がはるかに簡単です
ハンドルを使って情報や 非同期呼び出しを常に管理する ネットワークプログラミングを たくさんやったことがあれば これは非常に直感的な構造です
これは基本的にはそのために使われます
また ゲームプレイエフェクトハンドルの取得や ゲームプレイアビリティハンドルの取得には さまざまな方法があるので 進行中のものを操作することができます
そして最後に ゲームプレイエフェクトを適用した後 アクタを破棄します
1つ気付くと思いますが これに当たるとヒットバックエフェクトが 返ってきます
そして ゲームプレイエフェクトの中には どこにもそのヒットバックが表れるように プログラムされていません
また ピックアップの中にもヒットバックが 表れる原因となるところがありません
私は ゲームプレイキューを使って このゲームプレイエフェクトに付随する 視覚効果を トリガーしているのです
ゲームプレイイベントと言いそうになりました ゲームプレイキューは 基本的に ゲームプレイエフェクトがキャラクターに 適用されるときに 必要な視覚効果またはその 他の種類のコスメティック情報を カプセル化する方法です
したがって この例では この再生キューがあります
これが この再生エフェクトをトリガーしたときに 表示される視覚効果です
それが何をするかというと... まあ それは明らかですが しかし それがどのように 機能するかが問題です
再生のゲームプレイエフェクトに行って [Display (表示)]プロパティに行くと ゲームプレイキューのリストがあるのがわかります
そして それがスポーンするプラグインしている オブジェクトのリストの代わりに ゲームプレイキュータグのリストがあります
ここでゲームプレイタグシステムが 再び登場しました
そして ここではHealth.Regenerationタグを適用しました
つまり このゲームプレイエフェクトを キャラクターに適用すると これらのタグに一致するゲームプレイキューを 探して適用します
そして ゲームプレイキュー自体の中で ここでゲームプレイキュータグを見ると ここがそれを定義する場所です
だから ここにHealth.Regenerationを設定しています
そして再生ゲームプレイエフェクトでは ここで設定します
そして それらが一致する限り 自動的にそれらを 一致させてキャラクターに適用しようとします
同様に メレーダメージのヒットバックは Health.Damage.Meleeを探しています
それはこれらのゲームプレイキュータグを 使用する すべてのゲームプレイエフェクトに適用されます
これは基本的に 一般的な視覚効果 オーラ ヒットバックをゲームに 設定するのに非常に便利な方法です...
1つのゲームプレイエフェクトだけでなく ゲーム全体のすべてのゲームプレイエフェクトに そのため これらのさまざまなエフェクトを 有効にする正確なポイントを 見つけるために 特殊なプログラミングをする 必要はありません
トリガーしたいエフェクトの ライブラリのゲームプレイキューを作って これらのタグで結び付けて これらのキューを表示させるタグのライブラリを 持っていればいいのです
その点では これらが 実行される方法に関しては サウンドキューと似たような働きをします
つまり これらが実行するときに 起動される関数があり それに発生したばかりの ゲームプレイエフェクトに 付随するターゲットや パラメータ内の情報に基づいて さまざまな機能をトリガーするように 指示できます
ここにBP_GC_MeleeDamageCueが あります
これはGameplayCueNotify_Staticから派生したものです
これは 2種類のゲームプレイキュークラスを 作成できる別のケースです
基本的にGameplayCueNotify_Staticは単発エフェクトです
それはワールド内でインスタンス化され 発生して実行され そして消滅します
だから ヒットバックのようなことをしているなら それはその手のキューの 典型的な使い方です
ここでは GameplayCueNotify_Actorを 再生エフェクトに使用しました
これがゲームプレイエフェクトです
ゲームプレイキューが欲しいのです
これが再生キューです
これはワールド内で インスタンス化する実際のアクタであり 目に見えない形で存在する単なる UObjectではありません
Notify_Actorキューは基本的に 物理オブジェクトのように使用でき ティックロジックを追跡することができ 実行されたときと削除されたときに 起こることや アクティブなときに起こることを 追跡することができます
だから もっと洗練されたことが できるようになります
ここではキャラクターに パーティクルシステムコンポーネントを アタッチした いや ゲームレイキューにパーティクルシステム コンポーネントをアタッチしただけです
そしてデフォルトでは このキューがそれを所有するキャラクターに 基本的にゲームプレイエフェクトの 対象となった人に アタッチするように設定しています
そして それを扇動者ごとに 一意のインスタンスで設定しているので 異なるキャラクターがこれの独自のコピーを 持つことができます
これがこれらをプールする方法です
メレーダメージはずっと単純です
適用されているダメージの ターゲットを取得します
そして 起動するエミッタを スポーンするだけです
そして それが起こるすべてであり そしてグレイストーンを使って... グレイストーンの綴りを間違えました
Eです そしてP_Greystone_Primary_Impact視覚効果を与えるだけ スポーンするだけです
そして それが起こるのを見ることができます
私が誤って消していなければ ちょっと待ってください
どこかで違うヒットバックを選んだかな？

VICTOR:
小さいのが見えたようですが

MICHAEL:
何か変なことをしたかな？
そうですね グレイストーン
Primary_Sparks これです
これが私が使っていたエフェクトです
少なくとも 私が使っていたエフェクトだったと思います
ブループリントを コンパイルするのを忘れていたのかな？
これをちょっと見てみましょう
Primary_Sparks [Play (プレイ)]を クリックします
これじゃありません
Primary_Impact
Primary_Impact これです
間違ってSparksを使っていました
これもまだ...
これはトリガーした
それで このメレー攻撃はどうなっているんだ？
はい バグもあります

VICTOR:
そうですね
初めてではないし 最後でもありません

MICHAEL:
確かに
それでメレーダメージだが 誤ってタグを外してしまったかな？
BP_GE_MeleeDamage
Health.Damage.Melee
はい 大丈夫
もしかして...ああ
エフェクトのトリガーさえしていない
なぜかこのアビリティを壊してしまったようです
不思議だ
まあ あまり手間取らないようにしましょう
マグニチュード属性

VICTOR:
このような問題の
トラブルシューティングを行う方法を
見るのもよい場合があります

MICHAEL:
はい
はい それはいい考えですね
修飾子
ああ はい
わかりました
間違ってこの修飾子をここに 追加してしまったからだと思います
普通にやれば...はいできました
これで 実行計算の邪魔をすることなく 意図したとおりに動作するようになりました
私がどのようにして これらのアビリティを作成したか 最初から最後まで説明します
しかし 皆さんにこれを構成する すべてのコンポーネントに 馴染んでもらいたいのです
ゲームプレイアビリティは十分複雑なので 本当に基本的なことを始める前に さまざまなコンポーネントをすべて知っておく 必要があることがわかると思います
ですから これらの構成の説明を理解するのが 少し難しいようでしたら おわびします
しかし それはここで説明します
これがゲームプレイキューです
ところで 必ずしもゲームプレイキューを使って すべての視覚効果をトリガーする 必要はありません
アビリティやエフェクト キャラクターやモンタージュなど さまざまな場所で必要に応じて 視覚効果やサウンド効果などを 発生するための 特殊コードを作成することができます
ここにグレイストーンの 剣の軌跡を設定したので それは彼のアニメーションモンタージュにあります
しかし ゲームプレイキューは ゲームプレイエフェクトに特化した 便利なコンパニオンクラスであり ゲームプレイエフェクトを簡単に設定できる ヒットバックなどのための 本当に汎用的なシステムです
そして最後に ゲームプレイエフェクトの スタンドアロン実装を披露した後 もう1つ付け加えます
必ずしもゲームプレイエフェクトをアビリティに 関連付ける必要ありません
それはオーナーとターゲット または少なくともターゲットが必要です
オーナーがある必要はありませんが オーナーから出てくる何かを 計算している場合は別です
ダメージピックアップや私が作った このヒーリングピックアップのような 一定の値であれば... そのような場合には オーナーの状態値を参照していなければ それが機能するために必ずしもオーナーを 割り当てる必要はありません
しかし オーナーを持つことは良い習慣であり エフェクトがオーナーを持つ最も簡単な方法は それがアビリティの中から発行されることです
それでやっと これがブループリントエディタ内に あるゲームプレイアビリティ そのものです
ゲームプレイアビリティは それ自体が特別なタイプの ブループリントです
それは このごちゃごちゃした話の最初に アビリティの背後にある理論とその仕組みを 説明したときに説明した機能を カプセル化しています
すみません ちょっとこれらのタブを いくつか閉じさせてください
いくつもいくつも開いて混乱しないように
これがメレーアビリティです
そして何が起きるかというと AbilitySystemComponentから Activate関数を呼び出すと それはActivateAbilityイベントを トリガーします
その後 EndAbilityに到達するまで そこにあるどんな実行も行います
そしてこれは アビリティがもはや使われていないことを示します
こうすることで AbilitySystemComponentを解放して 他の種類のアビリティを使用できるようにします
別のアビリティが他のアビリティを ブロックしている場合など アビリティの実行をコントロールする主な方法は ゲームプレイのアビリティタスクと呼ばれるものを 使用することです
アビリティタスクは 特別なブループリントノードで... 起動する単一の関数を表すのではなく オブジェクトを表すものです
アビリティタスクは アビリティタスクオーナーに追加されます
つまり AbilitySystemComponentが それらすべてを管理します
使用しているこれらの ノードのすべてのコンポーネントに 目に見えない形でアタッチされている このタスクのインスタンスがあります
そのため タスクインスタンス名が 付いているので タスクを調べて何かしたいときに 名前を指定できます
そして これらには アビリティ自体と同様に 開始中 進行中 および 停止の概念があります
また それらはこのように タスクのためにオブジェクトの周りに ブループリントノードをラップすることができます
つまり ブループリントノード自体に 複数の異なる実行パスを持つことができます
したがって これは アニメーションモンタージュが 終了すると発生します
それは 次のアニメーションに ブレンドし始めると このピンから発生します
割り込み時にこのピンから発生します
あるいはキャンセルすると これらの異なるピンから発生します
同様に Wait Gameplay Eventがあります
これができるのは... 「ゲームプレイイベントを待機」が 本当の意味での名前です
そして 特定のタグが適用された一般的な ゲームプレイイベントが来るのを待ちます
これは AbilitySystemComponentを 所有するキャラクターの内部で メレーストライクイベントが 発生するのを待機しています
このノードを作成すると AbilitySystemComponentは これをリッスンします
そして これらのタグに 一致するイベントを受け取ると それはEvent Receivedを発生して このペイロードと一緒に含まれるターゲットに ゲームプレイエフェクトを適用するための 信号を与えてくれます
別のタスクの例として キャラクターにルートモーションを 適用するタスクがあります
したがって キャラクターをある場所に移動させ 目的地に到達したときに実行ピンを 発生させる場合は このノードでそれができます
そして キャラクターは... これをトリガーすると キャラクターのルートモーションを引き継ぎ 通常の動きが無効になり ここで指定したカーブに沿って この最終目的地に向かって移動します
実際 さまざまな ルートモーションアビリティタスクがあります それらが実際にやっているのは... アニメーションモンタージュシステムを 使ったことがあるなら アニメーションにいわゆるルートモーションが 含まれている場合があります
これはアニメーションの中で キャラクターの原点に ルートボーンがあるところです
そしてそのルートボーンを動かします
すると アニメーションシステムと 特にキャラクタームーブメントコンポーネントは ルートコンポーネントの動きから情報を 取得することができます
そしてキャラクターにアタッチされた モデルに適用するのではなく キャラクター自体に適用します
そうやってレッジクライムのようなものを やるのです
補間計算をしてキャラクターを レッジを登らせようとするのはとても大変です
その代わりにルートコンポーネント... いやルートボーンをアニメートして エッジの上に移動して ゲームプレイの中でそれを取得して適用し キャラクターの動きを 引き継ぐことができるのです
ルートモーションソースと呼ばれる ゲームプレイアビリティを念頭に置いて 構築されたシステムがあります
そこでは ルートモーションシステムを 手動で引き継ぎます それを乗っ取って 好きな動きをするのです
したがって シミュレートしたジャンプと 整合性のあるルートモーションをしたい場合は このノードを呼び出すと ルートモーションを引き継いでくれます
キャラクタームーブメントコンポーネントの 他のすべての移動が停止し 代わりにこれを行います
これが存在する理由は 任意に移動する必要がある ルートモーションを使用できるようにするためです
したがって グラウンドパウンド攻撃などを受けている場合 必ずしも予測することができません
そこでは 何らかのアニメーションスイート内で アニメーションを編集している場合... Mayaか何かの中にいる場合 ルートモーションが着地する必要があります
この1つのパスに正確に従うように アニメートできます
地面までたどり着き 地面を見つけて 地面に着くまでにどんなに時間がかかっても そこに行くよう指示するために必要です
これはそのためにあるのです
そのため このようなことをしているときに アビリティの実行中にキャラクターの 動きを非常に簡単に コントロールできるのです
それは これらのタスクによって直感的になる ものの本当に良い例です
そうでなければ アクタなどのティックコード内で 行うのは本当に苦痛です
このようなものを編集するには タスクのコードに飛び込むだけです
自分でカスタマイズしたプレイモンタージュと イベント待ちタスクがあります
実はテストしたかったので アクションRPGサンプルから 拝借しました
はい これです
異なる出力ピンに対応するこれらの異なる デリゲートオブジェクトがあるのがわかります
そして それは静的関数を持っていて それはブループリントノード自体が 参照するものです
これが ブループリント内で表れる方法を 定義しているものです
そして さまざまなロジックがオブジェクトのように 構造化されています
たとえば ワールド内にあってコードを実行する UObjectのようなものです
だから それはかなりわかりやすいプロセスです
そしてそのまますぐに利用できる さまざまなタスクがあります
物理システムのさまざまなオーバーラップを 待機するタスクがあります
さまざまな種類のゲームプレイエフェクトを 待機するタスクがあります
入力の確認とキャンセル
ですから... 私はここではしていませんが ゲームプレイアビリティを入力システムごとの 特定の入力にバインドし これらのタスク内でそれを リッスンすることができます
そのため アビリティのこの特定の ステップに到達したとき それがアクティブな間は プレイヤーが再びその入力を クリックするのを待つことができます
または 彼らがその入力を解放するのを 待つこともできます
だから ボタンを押したままにして グレイストーンが空中に 飛び出す一連のコードを実行して しばらくそのままにすることができます
そして プレイヤーが入力を解放するのを待って 着地すべき方向に 撃ち下ろすことができます
私はそのように機能するアビリティを 作成していません
このアビリティを作成したとき それを行う方法を 解読しようとしている最中でした
これは 単にルートモーションムーブメントを 行う原理を示しているのです
私はまだ 利用可能なすべての 異なるルートモーションタスクで何ができるかを 理解しようとしています
しかし ActivateAbilityがあり それがApply Root Motion Jump Forceに行きます
それはグレイストーンを 彼が向いている方向に 高さ2,000センチで1,500センチの 距離だけ動かします
彼が着地したとき 彼はアニメーション モンタージュをプレイすることになっていますが 私はこのモンタージュを実際にプレイするのに 少し苦労しています
次に そのエリアにあるポーンに対して 球体トレースを実行し それらにメレーダメージを与える ゲームプレイエフェクトを適用します
また ゲームプレイアビリティ内の ApplyGameplayEffectToTarget ノードは 実際にはオーナーを与える必要はありません
それらは アビリティのユーザーをオーナーとして取得し それをソースとして使用することを知っています
そうすれば少し手間が省けます
そして 一旦それを行うと この半径内に捕らえられたすべての人に このエフェクトを適用すると アビリティを終了します
ターゲットにエフェクトを適用するときに 実行できる便利なことの1つは ゲームプレイアビリティ内のこの関数が実際に このターゲットデータ構造体を使用することです
そして これは1つのターゲットまたは 多数のターゲットを含むことができるハンドルです
したがって ヒットしたいアクタのリストを 作成することができます
そして 終了したら 実際にこのHit Actors配列を使って それを内部に適用して この配列からターゲットデータを作成しています
このようなアビリティターゲットデータを 作成するための いくつかのユーティリティ関数があります
ヒットした結果 または異なるソースと ターゲットロケーションのいずれかを使用して... これがどのように機能するのか 正確にはわかりません
でも役に立つかもしれません
えーと 「target data from」...
そして 特定のアクタやアクタのグループから このヒット結果を使って それをプラグインすることができ それでもおそらく機能するでしょう
これを試してみましょう
これで余分な関数呼び出しとローカル変数を 節約できるかどうかを試してみましょう
それはかなりいいかもしれません
私は数メートル離れます
間違ったボタンを使っているので 誤って再生をトリガーしてしまいました
跳び上がります
彼をヒットします
確かに彼をヒットしたはずです
わかりにくいのです
いや ヒットしていません
わかりました
オーバーシュートしないように しなければなりません
必要なのは... これをカメラが向いている方向にして これが機能するために半径を示す 視覚効果を追加する必要があります
ああ
[笑い声]
大丈夫
ちょっと 勘に頼らないようにしましょう
彼に500センチジャンプさせて ジャンプを短くし 奥行きの感覚が問題にならないようにします
OK
ここからやれば できました
はい ヒット結果はうまくいきました
そして それは 球体トレースや オーバーラップイベントなど 使用したい種類のヒット結果から 直接取得できる 便利な簡略になります
そしてこのHit Actors配列はいりません
これで大丈夫です
「使用中のHitActorsはありますか？」
いいえ 使用中のHitActorはいりません
このFor Each Loopも必要ありません
簡略化 なんてすばらしい
まあ 実際にはヒット結果からそれをする 必要があるかもしれません
ええ 実際にそこからプラグインしています
このようにできるかな...いや
For Each Loopが必要です
For Each Loopが必要です
私の間違いです
今わかって良かった
でも もうこれ以上これをいじりません
これらの設定の説明が 既に長くなりすぎています
しかし これは アビリティタスクを使ってアクタの動きを調整して 非常に特定の順序でさまざまなイベントを ポップアップさせたり 異なるエフェクトを適用したりする方法を 示す良い例です
また Wait Delayタスクも用意されており このような処理が必要な場合は 任意の時間だけ待機することができます
ときには何かを アニメーションモンタージュに結び付けて コリジョンを トリガーしたい特定のフレームのようなものが 必要な場合があります
ただし 魔法をかけるような場合 アビリティのタイミングとアニメーションの タイミングを別々に 編集したい場合があります
このようにして キャストエフェクトアビリティを設定しました
これは アニメーションモンタージュをプレイして ゲームプレイエフェクトを適用するのにアビリティで 0.5秒待つだけです
これがゲームプレイアビリティを使って これらタスクを適用する方法の要点です
これが カスタムタスクを作成し それにさまざまな機能を 追加する方法の要点です
ここでクラスデフォルトの ゲームプレイアビリティについて重要な定型の いくつかを説明します
これは実際の実行について話す際に 完全にスキップしました
CommitAbilityという関数があることに 気付くかもしれません
CommitAbility関数を 呼び出す目的は... アビリティに関連するコストを ロックすることです
これは 基本的にアビリティを 強制的に失敗させる 最後のチャンスを示すために使用するものです
したがってコストセクションがあります そして マナを減らしたり ヒットポイントを 減らしたりするコストを 表すゲームプレイエフェクトクラスを アタッチできます
CommitAbilityは これらのコストを AbilitySystemComponentに 実際に適用するように指示します
自分で手動でやる必要はありません
定形の他の部分を見てみましょう
クールダウンセクションがあります
これは 特にアクションRPGや MOBAのようなもののために 作られたことを思い出してください
クールダウンエフェクトとは 基本的に このクールダウンの中に入れた アビリティエフェクトを発生するたびに 再びアビリティを使えるようになるタイミングを コントロールするものです
そのため 使用時にそのエフェクトを作成します
そして そのエフェクトが終了すると その持続時間に関係なく 再びそのアビリティを使用することができます
このアビリティエフェクトが有効である限り 自動的にそれを禁止します
そして タグを使ってできる これらものもののことがあります
アビリティ自体に それらに適用されるタグがあります
そして これは主に各種のアビリティの発生を キャンセルしたり 拒否したりブロックしたりするために使われます
つまり これらが このアビリティに属するダグであると 指定できます
AbilitySystemComponentを クエリーして これらのタグに一致するアビリティのリストを 取得できます
それが私がAIについて話していたことです
そのため 必ずしもそれが何であるかを 知らなくてもアビリティを選択し 汎用AIを書くことができます
だから メレーのアビリティを探すことが わかっている汎用メレーキャラクターAIや 回復アビリティを探すことがわかっている 汎用回復AIを書くことができます
タグを追加して 自身をターゲットにするかどうか 他をターゲットにするかどうかなどを 追跡できます
これには元々備わっている意味はありません
しかし 自分でスクリプトを書くことができます
使用しているアビリティについて この情報が正しいかどうかを確認し それに応じて使用することができます
そしてCancel Abilities with Tag
アビリティをアクティブ化すると ここで指定したタグを使用する その他のアクティブアビリティを 自動的にキャンセルしようとします
だから キャスティングでメレー攻撃を キャンセルしたい場合は このアビリティに対してそうすることができます
ブロックキングは 特定のアビリティがアクティブ化されるのを 明確に防ぎます
Activation Required これを使用するためには特定のタグがあることが 必要になります
そして その他もろもろです
また キャラクターとそのAbilitySystem Componentにアクティブなタグがある場合 それらを拒否したり 要求したりすることもできます
そして ターゲットも同じです
アビリティを許可する場合と許可しない場合の 一種のスイッチボードとして これを使ってできることがたくさんあります
それでは ゲームプレイアビリティの基本について 他に何を取り上げたら いいでしょうか？
これがほとんどです
私は...おっと こうしたいのではなかった
これがほとんどです
最後にやりたいのは これらの特定のアビリティが どのように設定されているか説明することです
私がまとめたキャスティングと ジャンプアビリティについて 説明しました
しかし 私が話していて本当に興奮したのは メレーシステムです
でも その前にどなたか質問はありませんか？

VICTOR:
多くの質問を受けました
集めていたので そのいくつかを聞いてみたいと思っていました

MICHAEL:
はい
質問をお待たせしてすみません

VICTOR:
そんなことはありません
Mike
最後に質疑応答を行います
最初にプレゼンテーションを 聞けば何が取り上げられたか確認できるので それからまだ話題になっていないものに 取り組むことができます
マルチプレイヤーに関して 多くの質問を受けたことを お伝えしておきます
それはまだ取りかかり中で 将来私たちがカバーしたいと 考えているということは 述べておいて良いと思います
さて ゲームプレイアビリティシステムが マルチプレイヤー向けに 用意されていることを 知っておくのは良いことですね
これは低レイテンシーで値を レプリケートできるように作られています
だから シングルプレイヤーだけでもいいから 先に使い方を覚えておけば まだマルチプレイを実装していなくても 既に半分のところまで 来ているということですね

MICHAEL:
まあ そんなところです
アビリティをシングルプレイヤーで実装して 後からマルチプレイヤーを 追加することを推奨するわけではありません
ゲームにマルチプレイヤーが 必要なことがわかっている場合は 最初からそれ用に構築するべきです
しかし 一例として これはゲームプレイアビリティシステムの 操作やアビリティの 設定方法などの基本的なことを知ってもらい それを使ってもらうためだけのものです
レプリケーションは はい まだそれを行う最適な方法を 調べているところです
そのようなことを処理するために システムにはさまざまなアフォーダンスが 組み込まれています
実際 ルートモーションはその1つです
それは ルートモーションソースに 関する話に大きく反れたときに 忘れていたもう1つのことです
これを行う理由は キャラクタームーブメントコンポーネントは ルートモーションを 自動的にレプリケートできるからです
このようにルートモーションを ハイジャックすることで 何もしなくてもルートモーションをレプリケートする 既成の方法ができます
他にもGameplayAttributeSetに レプリケートするように指示して 望む異なるユーザー設定に応じて異なる値を レプリケートし レプリケーション通知関数を使用して 自分で宣言する通常の変数と同じように 一連のロジックをトリガーできます
これらは レプリケーションを 設定するためにできることの例です
渡されるハンドルはすべて レプリケーションの追跡にも役立つと ほぼ確信しています
そしてもちろん ソースとターゲットの概念があります
アビリティのソースは アクタの扇動者に類似しています
これは レプリケーションを 容易にすることを目的としています
これらは レプリケーションとの連携に役立つ 私が見つけた いくつかの例です
しかし 私が言ったように それを適用する最善の方法はまだ研究中です
そして 私たちはそれについての ガイドをまとめます
それは私が言いたかった もう1つのことで その核心をスキップしました
私たちはこれに関する資料を 大幅に改訂しています
先ほどお話ししたすべてのクラスの リファレンスページを大幅に拡張しています
それらの使い方やここにあるエフェクトを 再現するためのハウツーガイドなどです
このようにしてこの種のものを 学びたいのであれば 数か月以内にそれらのドキュメントが公開され その資料が利用可能になるでしょう
これは そのようなものすべての ちょっとしたプレビューのようなものです
そういうことで 他にはどんな質問がありましたか？

VICTOR:
では準備はいいですか？

MICHAEL:
うーん

VICTOR:
KaosSpectrumさんは GAS (ゲームプレイアビリティシステム)では ノックバックなどを実行するには どうすればよいのかと尋ねています

MICHAEL:
それはゲームの具体的な実装と ニーズに大きく依存します
つまり ルートモーションのタスクは 必ずしもそのようなことを行うために 使用するものではありません
これらは アビリティのオーナーをターゲットにしていることを 前提としているからです
代わりに使うのは ゲームプレイエフェクト...

VICTOR:
すみません Mike
Seth フルスクリーンにできますか？

MICHAEL:
すみません
先走りしてしまった
私が彼に合図することになっています
これでフルスクリーンになっていますか？

VICTOR:
まだです
ちょっと待って
よし できました
はい どうぞ Mike
はい

MICHAEL:
OK 先ほど言ったように
これらのルートモーション類はキャラクターを 非常に特殊な方法で動かすためのもので 実際それらがモーションと アビリティを実行する方法のためです
その代わりに何をするかというと ノックバック用に作成された ゲームプレイエフェクトを適用します
実際にここでやってみましょう
大文字ロックになってる
このゲームプレイエフェクトを使い...
BP_GA_Knockback
それからそれが...
どうでしょう
関数を見てみましょう
目立つ関数はありません
目立つイベントはありません
はい これはおそらく最善の方法ではないですね
まあ 実際には はい うまくいきます
その方法はこうです
ノックバックエフェクトを設定します
ゲームプレイ...GA_Knockbackじゃない
GE_Knockback
プレフィックスが混乱しています
このエフェクトを設定します
修飾子を追加してアトリビュートを指定するか
ノックバックをどのように 扱うかのカスタム計算を指定します
それは用意したダメージフォース変数に 基づいているのかもしれません
GameplayAttributeSetの中で そのダメージフォース変数を定義します
どこだったかな？
一時的プロパティとして
そして修飾子を指定するときは この値に基づいて行います
そしてそれを行うと CPPファイルの AttributeSetに移動できます
すみません この説明ではちょっと ざっくりとした話をしています
AttributeSetに移動できます
これです
これが探しているCPPです
PostGameplayEffectExecuteに 移動して 「if (Data.EvaluatedData.Attribute == GetKnockbackAttribute())」と入力します
つまり 何をしているかというと ダメージフォースがあります
これを計算に使って キャラクターのノックバックに適用します
これはキャラクターの状態値ではありません
これは 使っている値を表しています...
受けたダメージのような必要な 情報を点滅させています
ここで私が言いたいのはKnockback ForceTakenだと思います
「GetKnockbackForceTakenAttribute」
それのプロパティゲッターを作成します
そして見てみましょう
これでうまくいくはずです
これをベースにコードを実行するように 指示できます
そして それが物理システムを 使って実際に力を加えたい場合でも そうすることができます
ムーブメントコンポーネントを使って カスタムムーブメントステートを作り ノックバックフォースに応じた カーブに沿ってキャラクターを手動で 移動させたい場合は そのようにすることができます
このステップを完全にスキップして ゲームプレイエフェクトをいじり回したくないなら これはデータ駆動型にする良い方法ですね
これは キャラクターから取り出して それが何であるべきかを決定するのに 便利な計算を行う方法です
つまり キャラクターの強さに基づいて エフェクト計算を行い それに基づいてノックバックを適用する場合 そうすることができます
でもそれを完全に飛ばして... ええと ここのメレー攻撃に飛び込むことができます
ダメージエフェクトを適用するときは そのまま... ルートモーションフォースではなく ターゲットアクタを使用します
どうやらこのアクタをターゲットにできるようです
いいえ いいえ
それは ロケーションアクタです
それは それは的を絞るためのターゲットです
ええと...いちいちここから 上にドラッグしなくて済むように 今すぐキャラクターにキャストしましょう
できました
これがすべての物理関係です
普通のゲームプレイ呼び出しをして それにフォースを加えることができますね
それをノックバックにできます
そのようにして上向きと後ろ向きのフォースを 適用することができます
あるいはキャラクターに物理システムを 使用しないフォースをシミュレートするための カスタム関数がある場合は それらの関数を直接呼び出すことができ なんでも好きなことができます
それはすべて それをゲームに適用するための最良の方法と ノックバックフォースを 表す方法によって異なります
物理を使う人もいるだろうし たとえば Unreal Tournamentのことを 考えれば 大量の爆薬がキャラクターを 空中に放り投げたり 彼らのベロシティを設定します
少なくとも瞬間的に 実際には ベロシティの設定の方がおそらく... ええと
GetVelocityはありますが
SetVelocityはありません
何をしているかによっては ベロシティの設定の方がより エレガントな方法かもしれません
それを行うには 簡単なものでも詳細なものでも さまざまな方法があります
私の考えでは ノックバックエフェクトを 作成してそれ自体を適用するように指示する...
実際には これを「受けたノックバック」用に コンパイルする必要があります...
これを「受けたノックバック」 アトリビュートに適用し その結果に基づいて計算を行うのが おそらく私が実装しようとする方法です
他には？

VICTOR:
次に行きましょう
すみません
チャットに入力していました
johnathanharkeriscoolさんは 次のように質問しています
「ゲームプレイエフェクトを予測的に 削除するためのヒントはありますか 追加のエフェクト 削除エフェクトを 予測的に適用するサンプルプロジェクトを 見たことがありますが 余分なゲームプレイタグ 削除タグ これはちょっと格好悪いと思いました」

MICHAEL:
削除ですか おもしろいですね
アビリティを追加するための 仕組みがいくつかあります
ゲームプレイエフェクト自体がキャラクターに アビリティを付与できます
したがってこのエフェクトが継続している間は 「キャラクターにこのアビリティを与える」は できることです
しかし削除 ここでキャラクターでやったのは... GrantAbility、ActivateAbility、 CancelAbilityです
CancelAbilityは 私たちが望んでいるものではありません
ここで欲しいものは キャラクターから アビリティを引き離すということです
そうですね
そうですね
アビリティを削除し アビリティを適用する... GrantAbilityは私たちが 望むものと反対だ
ClearAbilityですか？
ClearAbilityは アビリティを取り除く機能です
そして 必要なのは AbilitySpecHandleです
AbilitySpecHandleは キャラクターにアビリティを 与えるときに作成されます
これは 単にアビリティの作成時にその参照を 追跡するために使用できる構造体で 非同期コールバックの追跡に似ています
そこらに AbilitySpecHandleがある限り この関数を呼び出して取り除くことができます
アビリティを削除する より整理された直感的な方法を 作成するという意味で クラスに基づいて 削除する方法があるか見てみましょう
TryActivateAbilityByClassがあります
FindAbilitySpecFromClassがあります
つまり AbilitySpecHandleを 取得することができ... FindAbilitySpecFromClassを使用して AbilitySpecを取得してAbilitySpec Handleを作成することもできます
そこらにそのアビリティのコピーがあれば それを見つけ特定のアビリティを取り除くために 使うことができます
アビリティの削除は 現時点では追加するよりも困難です
これはその編成方法に原因があります
これは使い勝手がいい方法とは言えず アビリティの削除を管理する正確な方法は その編成の仕方次第で ゲーム特有のものになります
多くのゲームでは ゲームプレイを 初期化するときにキャラクターにアビリティを与え ゲームの間ずっとアビリティを 持つことになります
これが元々の 用途だと思います
しかし その記録を残しておく必要があるなら 与えられたアビリティの リストを残しておく必要があるなら... ええと

VICTOR:
Jonathanさんは 必ずしもアビリティではなく 特にゲームプレイエフェクトのことを 言っていたのだと思います
もちろんこれも良い情報ですが

MICHAEL:
まあそれに似たロジックです
ゲームプレイエフェクトを トリガーしているのであれば この機能については 比較的詳しいので 私はとっては実際話しやすいです

VICTOR:
KaosSpectrumさんが 言っていたことについても 少し付け加えると...
GASの知識がないが興味がある方のために 説明しますと 実はDave Rattiさんの助けを借りて 私たちが2年前 2019年にまとめた資料があります
チャットにリンクがあります YouTubeの説明とTwitchにも必ず 入れるようにします...
そこでDave Rattiさんは それらを予測して削除することは できないと説明しています
[聴取不可]は 予測キーが拒否された場合 それらをクライアントから削除します

MICHAEL:
それは知っておくと良いことですが ゲームプレイエフェクトの場合は ゲームプレイエフェクトハンドルが返されます
これを使用して エフェクトへのストーリー参照が 必要な場合に追跡します
これらの参照をどこに置くかは ゲームと それをどこに置くと意味があるか によって決まります
しかし それを使用するのは...そこで
したがって[入力中]「remove effect」 見てみましょう
何かこれをやる方法があるはずです
おそらくこの参照を使って これはそれらから情報を得ています
これは削除待ち RemoveGameplayEffect FromOwnerWithHandle
これは それを行うための ゲームプレイアビリティ内の関数であり 必要な数のエフェクトの インスタンスを削除します

VICTOR:
いいね
ええ 予測オプションが 難しいところだと思います
確かにDaveは...

MICHAEL:
はい 彼は私よりも 多くのことを知っています
私はこのシステムを 教えようとしている人たちと一緒に このシステムを学んでいるので 見逃していることがたくさんあるかもしれないという ことを 改めて注意してください
それは確かにそのうちの1つです

VICTOR:
それでは last_devil_さんが尋ねています
「アビリティのアクティブ化を UMDボタンにバインドするための 回避策はありますか？」
これはモバイルに便利です

MICHAEL:
具体的にそれを行うのは AbilitySystemComponentに 組み込まれています
ちょっと待ってください
AbilitySystemComponentには ボタンとキーコードに関して 入力にバインドする 機能があることは知っています
見てみましょう
イベントを待機します
どこにあるかな...
開いてない 当然です
はい 実際にはカスタムの AbilitySystemComponentが ありません
キャラクターに移動します
ここに戻って 「AbilitySystemComponent」 見てみましょう
ここの LocalInputPressedがあります
ここで...これを介して入力IDを 割り当てることができますが これは必ずしもボタンに割り当てるために やりたいことではありません
基本的に 入力コードが実際には 一般的な整数にすぎない 現在の設定方法でそれを行う場合は これらのアビリティに割り当てる入力コードが...
実際にはこれをグレイストーンで 初期化することについては話していませんでした
ですので 今がその話をするいい機会です
これをアビリティリストで初期化しました
グレイストーンが利用できる アビリティクラスのリストを作って それを加え... さまざまなアビリティをこのリストに加えました
そして それらのアビリティをすべて与え それに入力コードを割り当てる 初期化関数があります
これはGrantAbility関数の内部で行われ AbilitySpecを作成します
これは ライブアビリティに関する 情報を取得したり アビリティを削除したりするために使用できる そこらにある参照の1つです
InputCodeはただの32ビット整数です そしてLocalInputPressedで ActivateAbilityを呼び出すと それによって発生します
しかし ここのメレーシステムで行うように キャラクター内で このActivateAbility関数を呼び出すと 特定の入力コードを 使用するように手動で指示しているだけです
したがって 特定のボタンに バインドされることがわかっている場合 実際にやっているのは そのボタンに割り当てられた入力コードで アビリティをアクティブ化するように 指示する関数を そのUMGウィジェットに割り当てることです
そしてそれは...
マップします...
UMG入力をこのアビリティにマップしてくれます
入力システム自体を使って画面上の ウィジェットにマップする方法があるのであれば 私はそれについてさらに調べる必要があります
近日公開予定のドキュメントに入力マッピングを 載せる計画があることは知っていますが 少なくともここにあるロジックで 動作させるためには これが最も簡単な 方法だと思います

VICTOR:
いいですね
そして 少し遅れて参加してくれた人もいる かもしれませんが Michaelは 彼が取り組んでいるゲームプレイアビリティ システムに関する新しいドキュメントが あることを先ほど述べていました

MICHAEL:
はい
このメレーの機能を紹介する前に もう1つ質問を 受けましょう

VICTOR:
わかりました
はい あと2ページあります 参考のために...

MICHAEL:
あと2ページ
[笑い声]

VICTOR:
2ページ
質問と残りの時間について 皆さんの参考のため 私はすべての質問をMikeと Dave Rattiさんにも送ります
また 彼らが答えられ コミュニティ全体と話し合うのが 重要だと思うものがあれば 彼らがフォーラムのアナウンスポストで 回答することができます
そこでは 私たちのすべてのライブストリームを 毎週発表しています
forums.unrealengine.comの 「Events」セクションにあります xNaxdyさんの質問です
「ゲームプレイアビリティは 実際の制作に使用できますか？ そしてそうだとしたら 開示できるのでしたら将来のロードマップを 教えていただけませんか？」

MICHAEL:
ゲームプレイアビリティの 今後のロードマップが どのようなものになるのかはわかりません
開発者の間では システムを改訂し もっとブループリントからアクセスしやすく ユーザーフレンドリーにすることなどに 関心が集まっています
実際 私が複数の場所で説明してきたように 多くのクラス間の関係は 必ずしも自明ではありません
C++に飛び込んで 作業しなければならないことが たくさんあります
しかし 予定は... 修正の具体的な予定はわかりません
実際の制作に使用できるかどうかについては 現在のシステムで出荷するゲーム全体を サポートできます
唯一の注意点は このセッションの最初に言ったように ブループリントレベルでデザイナーに 公開する必要があるものを すべて補完する必要があることと そのための独自のワークフローを作る 必要があるということです
したがって 基盤となるシステムは すべてうまく機能します
ワークフローは 自分でカスタマイズして編集する 必要があります

VICTOR:
いいですね
ええ 続けてください それから もう少し質問の時間があるか見てみましょう

MICHAEL:
このシステムを使った 製品を複数出荷しました
実際...今すぐ言えるのは Unreal Launcherの [Learn (ラーニング)]タブから入手できる アクションRPGサンプルプロジェクトは アビリティシステムも使用しているということです

VICTOR:
今マーケットプレイスにあると思います

MICHAEL:
マーケットプレイス... マーケットプレイスですか
それとも[Learn]タブですか？
両方にあると思います
両方で探せると思います

VICTOR:
両方とも？
両方ともです いいですね

MICHAEL:
はい
いずれにせよ ここではこのシステムを使って メレー攻撃を行うことについての理論を話し ゲームプレイ固有の実装の意味を 説明します
注意してほしいのは これは非常にシンプルなプロトタイプ版の メレーシステムです
それは必ずしも... 失礼 しゃっくりです... 出荷したい方法ではありません
その理由は 私がその詳細をお見せし始めたら わかると思います
しかし それはメレー攻撃を 行うための出発点が どんなものなのか理解してもらうのに いいでしょう
まず グレイストーンで [Debug Melee]をクリックします
メレー攻撃の背後にある理論は 基本的には コライダーや何らかの オーバーラップコンポーネント または球体トレースなどのトレースを使用して その中にあるすべてのターゲットを 検出するというものです
特に一度に複数のターゲットをヒットしたい場合 次に それらにダメージを与え それらをヒットしたターゲットの リストに追加します
そして ヒットターゲットのリストに追加すると 後続のオーバーラップイベントが 同じキャラクターを 2回拾うのを禁止できます
これがどのようなものなのかを お見せするために メレー攻撃を扱うイベントグラフ全体を 用意しました
このPerformMeleeHitboxTrace関数は 基本的にすべてのフレームで起動されます
そしてこれはポーンアクタの 球体オーバーラップを行います
そして 球体オーバーラップの中で検出した すべてのポーンを取得します
そして それらを このメレーヒットターゲットに追加します
ちなみに 皆さんに見せられるようにする前に これをクリーンアップするつもりです
このスパゲッティのような ブループリントコードについては 申し訳ありません
かなり短時間で作ったので このオーバーラップによって 検出された人すべてを このヒットターゲットのリストに追加します
そして 既にそのリストに入っている場合は それらを追加しようとはしません
まだリストにない場合 新しいものであれば メレーストライクを受けたという ゲームプレイイベントを送ります
そしてこれはフレームごとに呼ばれます
フレームごとに呼び出されるだけでなく 複数の異なる球体トレースでも 呼び出されます
それがどんなものかお見せするために 剣を振ってみましょう
ご覧のように フルスクリーンにすると 彼がブレードを振るとフレームごとに ブレードの軌跡に沿って さまざまな点で球体トレースが 行われているのがわかります
これはメレーコリジョンシステムでは 典型的なことです
ここに行く必要はありません
グレイストーンの メレーロジックに行かなければなりません
ウィンドウが多すぎます
基本的に キャラクターがブレードを振っている間は そのエリア内のコリジョンを 連続的に検出する必要があります
これは ブレードがこの軌跡を横切る位置を ユーザーの頭の中に 記録する期間があるためです
そして その軌跡のどの点でもターゲットを ヒットできるはずだと考えるのです
アニメーションが アクティブになっているこの時間内に ブレードがキャラクターにヒットする 許容範囲の感覚が欲しいのです
そこで コライダーをアクティブにするか 球体トレースを開始するか コリジョン検出に使用しているメカニズムを 開始します
次に ヒットアクタリストにアクタを追加します
そして そのリストに入っている限り 再びヒットされないという考えで ヒットイベントを適用するのは一度だけです
そして攻撃が終わったら リストをクリアすれば別の攻撃をして 2回以上攻撃できるようになります
あるいは 本当にけちなボスキャラクターを使って 格闘ゲームをしたことがあるなら やりたければ異なる間隔で ヒットアクタリストをクリアして 手動でリフレッシュすることもできます
これが同じアタックアニメーションで 誰かに2回ヒットする方法です
ブレードを振ってヒットして もう少し振って もう一度ヒットします
格闘ゲームの中でこんなことが起きると とても乱暴な感じです
しかし ほとんどの場合 90%の場合 誰かを一度だけ攻撃できるようにしたいのです
だからそのように設定するのです
Visual Studioが 何度も出てきてすみません
すぐ間違ったタブをクリックしてしまいます
メレーコライダーの 設定方法はさまざまです
私が個人的に気に入っている 実装をすぐに紹介しますが ゲームによっては 違ったものになるかもしれません
グレイストーンの アニメーションアセットへ行きます
ここで彼のプライマリ攻撃へ行きます
私がここでやったのは... 実はプライマリ攻撃は少し厄介です
彼の攻撃Cを使いましょう これはもう少しきれいに設定しているので
この攻撃のアニメーション通知には メレーイベントを検出するための 一連のトラックがあるのがわかります
そして 特別なアニメーション通知ステートが あります
アニメーション通知ステートは 機能をアクティブ化してから非アクティブにする フレームの範囲を指定します
ここに この範囲内でアクティブ化したい ヒットボックスのリストがあります
このリストを見て行くと...
もう少し直感的にわかるように彼の後ろに 回ってみましょう
右サイドのヒットボックス 中央右のヒットボックス 真中のヒットボックス 真中のヒットボックスとその少し前にある... 中央左 中央左2 左があります
したがって こうすると彼は左から 右にブレードを振っていて ヒットボックスを次々と アクティブ化します
これを機能させるために私は インターフェースクラスを作りました...
このブループリントに戻り... Melee Events Interfaceと言います
繰り返しますが これを行っているのが どの特定のクラスのアクタか知る 必要はありません
アニメーション通知を所有する 任意のアクタを選び このインターフェース関数を 実行するよう指示することができます
AddMeleeHitboxesと RemoveMeleeHitboxesは アニメーション通知で 指定したヒットボックス名を受け取ります
そしてNotify Beginで ヒットボックスを追加します
こいつは消して そして 私が定義したメレーヒットボックスの 全リストを使用します
この[Variables (変数)]パネルに 変数を追加するだけで カスタムアニメーション通知ステートに それらを追加することができます
そしてそれらは...こうして拾われ... こうしてここにあるモンタージュエディタで 拾われます
これがヒットボックスリストです
このアニメーションをプレイしているメッシュの オーナーに対して このインターフェースを使用して Add Melee Hitboxesを呼び出します
メッシュのオーナーが何かはわかりません
かまいません
それがこのインターフェースを持っていれば この関数を実行します
そして GreystonePlayerCharacter内に クラス設定があります
Melee Events Interfaceが 実装されています
その名前を得るたびに発生する 関数がいくつかあります
私はまた 「hitbox data」という データアセットを作成しました
hitbox dataは... これは単なるリストです
これは これらの球体を配置する場所の グレイストーンとの相対位置 その半径 名前についての 情報のリストです
これらの名前を使って参照しています
これをデータテーブルにするだけで この処理から多くの仲介物を 排除できるでしょう
データテーブルには 既に名前が適用されているので これを作ったときはちょっと実験していました
これはちょっとやりすぎですが 攻撃1中央右 攻撃1中央1 攻撃2左と グレイストーンが攻撃したときに 発生する可能性がある これらのヒットボックスの 定義があることがわかります
そして その参照を[Variables]パネル内で グレイストーンの ブループリントにアタッチしました
それから ヒットボックスを初期化するとき 私がしているのは 使用しているヒットボックスの名前と ヒットボックスの定義 それに属するオフセットと半径を含む マップを使用するだけです
実際にこれをアクティブなヒットボックスと呼ぶ エントリ内にラップしています
これには ヒット球体の定義からの すべての情報が含まれ この名前のヒット球体が アクティブ化された回数も含まれます
何が起きたかというと... ここのMeleeHitsに戻ります
私はAdd Melee Hitboxesを使います
そしてそれに指定する名前ごとに 名前を使ってヒットボックスエントリを 探そうとします
それがカウントを設定します
Countの値を1増やします
つまり 攻撃1中央1を見つけたといいます
それを増分する必要があります
そのCountを1増やします
この後 Countが1より大きい場合は そのヒットボックスエントリが
Active Hitboxesリストに追加されます
同様に Remove Melee Hitboxesは 名前でヒットボックスを検索し ActiveHitboxEntry内の Countを減らします
そしてCountが0ならば Active Hitboxesリストから削除します
さらに Active Hitboxesリスト全体を クリアし すべてのヒットボックスのカウントを 0に設定するための 別のユーティリティ関数あります
これは アニメーションモンタージュで どのヒットボックスが いつアクティブになるかを 簡単に編集するための方法です
ええと アニメーションブループリントはどこかな？
これです いや これはアニメーションブループリントじゃない
なぜいつもこれの アニメーションブループリントがなくなるのだろう？
探しましょう
これがそのモデルです

VICTOR:
今モデルを
開いたんじゃないですか？

MICHAEL:
ええそうするべきでしょう
うーん 実は そうなのか確かではありません
いいえ
このアニメーションブループリントはいりません
モンタージュがいるのです
必要なのはそれだけです
できました
これがアニメーションモンタージュです
このように要約することで...
これまでの長話から このようなヒットボックスエントリを 名前で追加するこのワークフローを要約できます
私はこのアークに適したヒットボックスになると 思うものを事前に記録しておき それらのヒットボックスの 名前をリストアップするだけです
必要なのはこれだけです
また 重複するヒットボックス名がある場合 たとえば ここで中央1が複数の 異なるフレームセットで使用されている場合 2つ目のコピーをアクティブにしたり 2つ目のトレースを実行したりする代わりに そのカウントを増分します
これにより 球体オーバーラップイベントの 実行方法がすっきりします
そしてヒットボックストレース...
これはアクティブなヒットボックスが複数あることを 確認しています
それは配置...
この一連の作業はもういりません
これはもう必要ありません
プレイヤー自身の位置に対してオフセットされた 位置でオーバーラップを行います
そして ポーンでオーバーラップを行い オーバーラップされたアクタを出力し 以下同様です
オブジェクトにも球体トレースを使用できます
その場合は 基本的に これを開始位置と終了位置に入れて 長さが0の球体トレースを作成します
そうすれば 検出されたアクタだけでなく 実際にヒット結果を出力することができます
これにより オーバーラップした場所などに 関するより正確な情報が得られるので エフェクトをトリガーするときにヒットスペックを もう少し慎重に配置できるようになります
これがアビリティシステムとやり取りする方法は Send Gameplay Event to Actorをとおしてです
この関数は タグを使用する汎用の ゲームプレイイベントをトリガーします
これには発生するタグとして Animation.MeleeStrikeが設定されています
これにこのイベントデータ構造体があり そこにはこのイベントを発生したときに 操作したい追加メタデータを 入力することができます
したがって ヒットスペックを適用する方法について 高度な情報が欲しければ エフェクトコンテキストを作ることができます
見てみましょう...[入力中] 「ability target data」
ヒット結果からアビリティターゲットデータを作成し それを入力することができます
これのゲームプレイキューに 戻ったら入って...
ゲームプレイキューはどこだ？
あった
これに入ると ここから出るパラメータには ヒットイベントの場所や 法線などが含まれます
ゲームプレイキューには この種のことをより正確に処理するための さまざまなパラメータが入力されています
ここにまとめたイベントデータと ターゲットデータ構造体が その情報を設定する場所です
しかし 一旦このゲームプレイイベントをアクタに送ると 何がそれをリッスンしているのかはわかりません
何かがリッスンしていることを 期待しているだけです
私たちはメレーアビリティ自体に入ります
アビリティをコミットさせます
使っている攻撃のモンタージュをプレイさせます
そのため これらのイベントはすべて メレーコリジョンシステムによって発生します
そして ここにあるグレイストーン ブループリント内で設定したような Animation.MeleeStrikeのある ゲームプレイイベントを待ちます
そしてペイロードを使います
これは私たちが設定した ゲームプレイイベントデータ このペイロード この情報満載のパッケージです
どこかな？
次に ターゲットデータを使用して
ターゲットにゲームプレイエフェクトを適用します
また ターゲットに関する その他の情報もここで使用できます
そして それが多かれ少なかれ キャラクターが 所有しているコンポーネントから ゲームプレイアビリティにターゲット情報を 渡す仕組みです
したがって この場合 メレートレースシステムはキャラクターに アタッチされるように設定されています
これは本質的にキャラクターの一部です
キャラクターがこれらのオーバーラップイベントを トリガーしています
そのようにしているのは メレートレース行うものを まとめるためです
このメレートレースを行う必要がある すべてのメレーアビリティの中でこれを しているわけではありません
ここでは そのメレートレースを行い そこに情報を渡す1つの共通点を 参照しているだけです
同様に ヒットする発射体がある場合 ゲームプレイイベントを送るかも...
ヒットターゲットのペイロードを 含むゲームプレイイベントを 送るかもしれません
それを発射体のオーナーに送ります
発射体のオーナー つまり発射体の扇動者は 理想的には AbilitySystemComponentのオーナーと 同じであるためです
それは特に オーナーに基づいて何かを 計算する必要がある場合です
あるいは ゲームプレイエフェクトを 直接トリガーするように指示することもできます
見てみましょう
ゲームプレイエフェクトを作成します
たぶんターゲットにゲームプレイエフェクトを 適用するのですね？
これを引き離して...ターゲットデータ [入力中] 「apply gameplay effect」
Make...違う
Target Data Has Actor
Append Target Data Handle
ところで ターゲットデータには 一度に複数のものを含めることができます
実際には 一連のターゲットデータをループして それらすべてを追加できます
同じ...これは既に話しましたね
すみません 何度も繰り返してしまいました
見てみましょう
ターゲットデータ...
[入力中]
おもしろい...
[入力中]
はい
ApplyGameplayEffectToTarget
関数を探すのに手間取ってすみません
覚える名前が多すぎて...
たくさんの名前が これでターゲットが得られました
これはアクタオブジェクト参照です
それはアクタの Ability System Componentです
そこでGet Ability System Componentをして ここに渡せばいいのです
その後このゲームプレイエフェクトを 直接トリガーできます
そして 発射体の扇動者があるなら それは必然的に便利なインターフェース呼び出しで Ability System Componentを取得し それをターゲットとして 設定することができることを意味します
そしてそれは アクティブな場合もあればない場合もある アビリティにイベントを 送り返すことなくこれを簡略して 発射体の中に入れるものです
しかし メレーの場合は キャラクターが武器を振り回している間は メレーアビリティはアクティブであると定義したので メレーアビリティが アクティブであることはかなり確実です
そして メレーアビリティがアクティブでなければ 決してダメージを与えたくありません
さて これらのヒットトレースを行うための 私の手法についてですが このようなコリジョンチェックを 行うためのメレーシステムを設定する 方法はいろいろあります
これは単にその1つです
私が見た方法の1つに... 単純にキャラクターの武器にコライダーを取り付け 武器のボーンに取り付けて それをオン/オフする方法です
私は 私が垂直トレースと呼んでいる方法を 使っている実装を見たことがあります
それは武器を使い 武器の最後の位置と 武器の現在の位置を得ます 時計の針が動いているように考えると 最後の位置を使って 武器に沿っていくつかのポイントを使い 現在の位置までトレースします
それはそれらのポイント間のコリジョンを検知して 武器を振り回す軌跡をシミュレートします
それも私がフォーラムやコミュニティの中で見た 一般的な人気モデルです
基本的にフレームレートと攻撃が フレームレートを横切る速度によって 信頼性が変わるため これらの方法の両方を 避けるようにしています
設定すれば気にしなくて済むので とても魅力的に見えます
しかし 問題は 剣にアタッチしているコリジョンボックスがあり それが1フレーム内で キャラクターの反対側まで 180度近くジャンプしてしまうと これが前のフレーム これが現在のフレームという状況を 作ってしまいます
これらの点ではコリジョンを検出しますが その間では何も検出しません
これは大きな問題です
同様に 垂直方向のトレースを行う場合は ここにあるブレードの先端からトレースし ここまでブレードを振って ここのブレードの先端まで トレースするようにできます
このように円弧を描くのではなく こうなります
そして それはキャラクターの体を横切るだけで 超 超短めで まったく役に立ちません
刺しもまた 垂直トレースでやるには 非常に不格好です
つまり アクションRPGプロジェクト以外で これを使用したゲームの実装として 見たことがなく 実際にはアタッチされたコライダーを 検出していると思います
これまでに手がけた このようなものを使った ゲームのほとんどは これは私がここで設定したように フレームごとに アクティブなコライダーや球体トレース ボックスコリジョンなどをコントロールして 検出したヒットキャラクターを 追加しようとします
つまり これらはすべて先ほど お見せした同じヒットアクタのリストに 集められます
それらをキャラクターの円弧に沿った さまざまな点でアクティブ化します
それらのコライダーの大きさと グレイストーンのブレードの大きさを 比べてみると少し不正確で あるように見えるかもしれません
ここでは かなりの余裕を与えています
非常に大きなエリアを ヒットしているように見えますが それに関しては 多くのメレーアクションゲームや アクションRPGなどでは 実際に余分な余裕が欲しいのです
私がこのすばらしい動きで示したように プレイヤーは常に世界最高の奥行き知覚を 持っているわけでありません
コライダーのサイズに少し余裕を持たせることで キャラクターの進路を横切るブレードの 完璧なシミュレーションをしたときのような 文字どおりの動作をするよりも フラストレーションが減り 感じるべきだと思うように感じることができます
さらに さまざまな点... コリジョンのさまざまな点でものを コントロールできます
そのため ブレードの先端にある球体が 追加のダメージを与えたり クリティカルヒットの可能性を高めるなど これらに追加データを設定できます
これには クリティカルヒット計算に適用される マグニチュードがあります
彼のボディに近いコライダーの方が 弱くなるように 設定することもできます
それをこのようにコントロールし始めると コンピュータが自動的に 攻撃のパスに合うよう何かしてくれることを 期待するよりも もっとうまくコントロールできます
同じように 本当に 本当に 凝った視覚効果を作ると... 多くのメレーアクションゲームは とてもポップなアーケードのような視覚効果を 持っていて ブレードからアニメーションアークが 飛び出して剣を振る 軌跡を示したりします
そして 多くの場合 実際には ブレードが当たるように見える場所ではなく それらの視覚効果に合わせてコリジョンを 調整する必要があります
これが余分な長さをコントロールするために そうしたいと思うもう1つの理由です
私がここで設定した方法は 必ずしもそれを構築する 最良の方法ではありません これは このようにフレームごとに コントロールしている この種のシステムの プロトタイプバージョンのようなものですが これは正しい方向に考えさせるのに 十分な機能を備えています
そして このかわいそうなUnreal Engine マネキンにダメージを与えるには 十分に機能を備えていることは 間違いありません
他には？
メレーコリジョンに関して 他に話すことはありますか？

VICTOR:
あと7分あります
できると思いますか？

MICHAEL:
ここでやめておこうと 思いますが 要約すると いろいろな種類の... そうだ 何を言おうとしていたか 思い出しました
私が言おうとしていたのは キャラクターのデータにアクセスした場合... ここにあるHitboxDataクラスは... これは必ずしもこの情報の記録を保持する 最良の方法ではありません
私がこれを行ってこれらを見つけた方法は アニメーションモンタージュのコピーを レベルにドロップしただけでした
モンタージュ...
そしてこちらの[Details (詳細)]パネルで 初期位置に移動してスクラブ再生できます
それが彼がこれの特定の時点でいる タイムコードを与えてくれます
そして ここに球体アクタを ドロップしてサイズを決めることができます
そして 彼をちょうど0, 0, 0に置き これらを彼の位置を基準に配置しました
そして 位置をコピーして これらのベクトル内に貼り付けました
そうやってその情報を得ました
これは この情報を扱うには不器用な方法です
実動環境でこのようなことをするなら この種のもののための カスタムエディタを作成して それをモンタージエディタ自体の中に ほぼ組み込むか あるいはモンタージュと攻撃用のデータの両方の ラッパーのような特別なエディタで 構築することになるでしょう
ここでタイムコードと位置球体を指定します
これはこの種のものを扱う はるかに直感的な方法ですが この種のシステムのプロトタイプとしては うまく機能します
あなたのゲームにはこれが適切かもしれません
このレベルの精度も必要ないかもしれません
必要なのは 攻撃時にキャラクターの前に 1つの球体をポップアップさせることだけです
MMORPGはこの種のもののために 驚くほど正確なメカニズムを持っていません
またはアクションRPGは トップダウンスタイルのアクションRPGなら 同じようなもののためにそれほど正確な メカニズムを持っていません
しかし メレーアクションゲームを作っているなら それはここでやっていることのようになるでしょう
これで私が言いたかったことは終わりです
申し訳ありません
必要なことをカバーし 注意事項を確認したかったのです
他に質問はありますか？

VICTOR:
ええ あと2、3できます
ではすぐ....
ここに印を付けたものがあります

MICHAEL:
いい質問が たくさんあるでしょう

VICTOR:
あります
答えられないものもあると思います
そのためチームの何人かが... 彼らは チャットで何度かリンクしたフォーラムの アナウンスポストに 参加したいと言っていました
o_dz_oさんが「ブループリントから新しい 状態値を追加できますか？」と尋ねています

MICHAEL:
ブループリントからの 新しい状態値の追加...
今のところ それをやる方法は C++でAttributeSetに行くことです
これはブループリントに 直接公開されている機能ではなく それを行う方法を作る必要があります
ええ とにかく それはかなり確かです
もしそれをする方法があれば それを調べて その方法についての情報を 提供するようにします
しかし それはできないと思います

VICTOR:
praise_solekさんが 「後リブートメッシュデプトをより具体化する計画は ありますか？」と尋ねています
すみません
「アトリビュートメタデータテーブルを さらに具体化する計画はありますか？ 他のプロパティも活用してもらいたいですね」

MICHAEL:
それは...それは自分で カスタマイズできるものだと思います
デフォルトの AbilitySystemComponentにある実装は プレースホルダのようなもので どのように動作するかの デモンストレーションにすぎません
AbilitySystemComponentを オーバーライドすると そのプロセスを引き継ぎ 最小値と最大値をゲームに合わせて 使用できると思います
または それを追跡するために 使用したいまったく異なるタイプの データテーブルがある場合は そうすることもできます

VICTOR:
わかりました
KaosSpectrumさんが別の質問をしました
「ゲームプレイアトリビュートの中でステートを 使用することの利点と 理由は何でしょうか？ たぶんGAですね 私はそれらは面倒だと思って使っていません」

MICHAEL:
ゲームプレイアビリティです
アトリビュートではありません
アトリビュートは単なる数値です
はい ゲームプレイアビリティ内の ステートの使用です
タスクはステートに似た構造体です
タスクは ステートの代わりに 使用したいものです
それらには実行した後 別の実行パスに沿って 別のタスクに進むという概念があります
それらはとても簡単に調整できます ゲームプレイアビリティ内にステートマシンを 実装することを考えているなら それが役に立つのは... 本当に複雑なアビリティを使いたいなら それは役に立つでしょう
たとえば アビリティの特定のステートに入り そのステートにある間 またはこの特定のタスクがアクティブな間に 一連の別のことを したいような場合です
それは可能ですが 私が作るアビリティのほぼ80%は そのためにステートマシンを 使うことはないと思います
アビリティタスクで十分だと思います

VICTOR:
theseedofjunaさんが
「GASはキャラクター動作アトリビュートをリッスンできますか？」と尋ねています

MICHAEL:
GASが何を...

VICTOR:
A-T-T-R
これは確かに アトリビュートだと思います
「たとえば キャラクターが 落下しているときや特定のフィードのときに アビリティを与える」
おっと フィードではなくスピードです
「もしできるとしたら それをキャスティングによって アニメーションブループリント内で 与えるのですか？ ありがとうございます」

MICHAEL:
ああ とてもおもしろいですね
ベロシティ用のアニメーションブループリント内で 与えるのですか？

VICTOR:
そこでそれをチェックできます
デフォルトの方法は アニメーション通知機能を 使用することだと思います

MICHAEL:
それを行う方法は... できることは キャラクターの現在の ベロシティ用にゲームプレイアトリビュートを 作ることです
そしてそれは ゲームプレイエフェクトで それに変更を加えることを 計画していない実装になります
それはちょっと...ちょっと... ええ ちょっと馬鹿げているかもしれません
でも プレイヤーの現在の移動速度を 読み取るために使いますね？
そこで ゲームプレイエフェクトをこれらに影響を 与えるためだけに使うという私のルールを 破ることになります
私ならCurrentVelocityを... GAMEPLAYATTRIBUTE_VALUE_SETTERにします
そしてもちろん それがUPROPERTYであることを確認し キャラクターに入って関数を定義します
次に AttributeSetで SetCurrentVelocityを 呼び出します
これは基本的に ゲームプレイエフェクトの計算に 織り込むことができる方法で キャプチャする方法です
いろいろな意味があるので これで納得のいく 答えになるといいのですが

VICTOR:
はい Junaさん
そうでなかったら教えてください
Alayaki Ireoluwaさんが 尋ねています
「話がありました」...そして実際 Daveからの答えがあります
「Network Predictionプラグインで GASを動作させるという話がありました Network Predictionプラグインが 完全に機能するようになるのは いつ頃になるのでしょうか？ また 包括的なドキュメントが提供されるのは いつですか？」
ドックにいるDaveは 彼らはまだ移動と物理の統合を イテレーションをしていて... ベースが固まったら GASをリリースすると述べています
そして それがいつになるか 予定はまだありません

MICHAEL:
ありがとうDave

VICTOR:
ありがとうDave
チャットの皆さん Daveに感謝してください

MICHAEL:
Daveに
感謝することがたくさんあります

VICTOR:
そうだな
Danny Bさんが尋ねています
「ゲームプレイアトリビュートではない カスタム計算クラスに カスタム値を渡すことはできますか？」

MICHAEL:
ちょっとダメージ実行を 見てみましょう
移動についての質問に答えた後 実際それについて考えました
理論的には ソースアクタがあれば そうすることができます
計算クラスを実行し ここにあるように実行パラメータから ソースアクタをフェッチして ベロシティを取得します
そして それは参照する ゲームプレイアトリビュートを得るという 面倒な手続きを踏まずに ベロシティを得る別の方法です
このように更新できる ゲームプレイアトリビュートにする利点は ドロップダウンから使用する 属性を選択するだけの より単純な他の種類の計算で その情報を得ることができるということです
そうすれば利用できるようになります
しかし 単にこの方法を使えば その情報を直接手に入れることができます

VICTOR:
そうですね
polymorrahさんが尋ねています
「FGameplayAbilitySpec FGameplayEffectSpecの目的は 何ですか？ なぜこれらが必要なのですか？」

MICHAEL:
なぜそれらの 命名規則がそのようなものなのか よくわかりませんが それの目的の背景は理解できます
AbilitySpecと AbilitySpecHandleは アビリティとそれがどこにあるかについての情報を 教えてくれる構造体です
アビリティに使用するC++実装のような 低レベルの実装のほとんどは 入力をとおして直接それをトリガーしたり それに入力コードを割り当てたりしていない場合 AbilitySpecを使用することになります
AbilitySpecに含まれているのは アビリティの参照だけではありません
そうでなければ それにクラスを与えることができますよね？
クラスごとにアビリティを与えるか クラスごとにアビリティをアクティブ化するか タグでアビリティを アクティブ化することができます
それはうまくいくでしょう
AbilitySpecには アビリティ自体への参照に加えて アビリティのレベルに関する 情報およびアビリティに関するその他の メタデータが含まれます
そのため C++の内部 またはそのようなものを たくさん公開したい場合は ブループリントで渡す方が より情報が豊富で 潜在的により便利です
ゲームプレイエフェクトハンドルは これに似ており ゲームプレイエフェクトにはレベルと 複数の状態値を割り当てることができます
EffectSpecには その情報が含まれていると思います
私は間違っているかもしれません 再確認した方がいいかもしれません

VICTOR:
KaosSpectrumさんが チャットで尋ねています
「specはspecificationの略で 情報を保持しています これは すべてのマグニチュード ターゲットなどを含む コンパイル済みの仕様に関する すべてを保持するために使用されるものです」

MICHAEL:
はい そうだと思っていました
私もそう思いました
しかし はい そのため...
それがspecの目的です
単にアビリティの参照のためのものではありません
それは アビリティ自体に埋め込まれていない その現在のコピーに関連付けられている データのすべてです
ハンドルは その位置をトレースし さまざまな場所から非同期に アクセスするために使用します

VICTOR:
Pequeno0さんが尋ねています
「実行時に新しいゲームプレイエフェクトを 定義することはできますか？ つまり 基本的にその場で新しいエフェクトを 生成することです」

MICHAEL:
それは潜在的に 可能なことです
そのため ゲームプレイエフェクトには ブループリント内にオーバーライド できる実行コードがあるとは限りませんが C++レベルでゲームプレイエフェクトを オーバーライドし イベントディスパッチャーをいくつか追加してから イベントディスパッチャーにイベントを登録して それらを起動させることも考えられます
同様に Construct Object from Class ここでゲームプレイエフェクトを取ります
Outerはどうでもいいです
同様に 単なる一般的な ゲームプレイエフェクトを作ることもでき それが公開されれば それに関連するすべての変数を変更し その場でそれを実行することも考えられます
今のところ それらは利用できないようです...
すみません
今のところ それらは変数としては
利用できないよう...
ああ ここにgetがあります
はい それらを取得できます
読むことはできても書くことはできません
カスタムのゲームプレイエフェクトクラスに 関数を記述して 実行時に構築される ゲームプレイエフェクトでそれらを 手動で設定できます
そして そのようにすることができます
または 一連のデータテーブルまたは JSONシートを読み取り それらのデータテーブルまたは JSONシートに一致するアビリティを コンテンツブラウザに自動的に入力する ツール類を作成することもできます
これは 自分で構築しなければならない カスタムエディタ機能のようなものですが デザイナーがデータ駆動式で これらを処理する方法を 考え出して エディタの外で 使いやすい方法で リストを生成したい場合には 便利なものになるかもしれません

VICTOR:
logicalcuberさんが 尋ねています
「アトリビュート変更コールバックで クライアントのUIを自動的に 変更する最適な方法はなんですか？」

MICHAEL:
アトリビュート変更コールバック...
最初に述べておきますが これは私がまだ扱ったことがない機能です

VICTOR:
Mikeは明らかに 挑戦することを恐れていません

MICHAEL:
私は 文書化されていないものや 文書化が比較的限られているものに 真っ向から飛び込みます
GameplayEffectUIDataという クラスがあります
具体的に何をするのかよくわかりませんが ちょっと見てみましょう
GameplayEffectUIData...
選択...
[入力中]「TestUIData」
これを開いて 関連性のある詳細はありませんね
イベントもないし
これはおそらく 公開されていない多くの C++機能を備えたものです
私の推測では UIデータは ゲームプレイエフェクトを作るときに 読むことができ そのゲームプレイエフェクトを表す ユーザーインターフェースにウィジェットを 適用するために使用できるメカニズムです
そのため アビリティの名前 アビリティのローカライズされたテキスト それに使うアイコンなどの 情報を保持するための ホルダーになります
そして 自分のUIのどこかで実行して このアビリティを追加するときに これをアイコンのリストに 追加するよう指示します
そして このアビリティを取り除くとき それを取り除きます
少なくとも それがどのように 機能するかについての 私の考えを裏付ける理論です
他のUIデータクラスを見てみましょう
UIData_TextOnly...
これはおそらく
より詳細に記述されています
はい これには説明があります
だから これが適用されると...
それがどこにルートされるのか どうやってそれにアクセスするのか 私にはわからないことが問題です
したがって 誰かわかっている人が チャットで説明しできない限り そのことについてはまた 別の機会にお答えしなければなりません

VICTOR:
pr_solekさんが尋ねています
「GameplayEffectUIDataには UMGで設定したりそこで 取り出したりする変数しかありません ステータスエフェクトを表示する名前や アイコンのようなものだけです」

MICHAEL:
私が説明したように 唯一の未解決の問題は UMGがどのようにしてそれに アクセスするのかということで それについては調べておきます
でも それは確かにいい質問です

VICTOR:
agt858さんが尋ねています
「ダブルキープレスを単一の アクティベーションバインディングに バインドするにはどうすればよいですか？」

MICHAEL:
ダブルキープレス はい
グレイストーンで説明した入力コードは...
基本的に任意にトリガーできます
それは...私にとってその入力コードは このリスト内のインデックスです
したがって代わりに グレイストーンスーパーアタックを作って ダブルタップにバインドすることができ それは...
ダブルタップを検出する 方法はいろいろあります
入力システムに何かあるか見てみましょう
それは間違っています
これはエディタ設定 プロジェクト設定です
それで これにはダブルタップ用の
アクションマッピングがあるのか
疑問に思っていて
実際にはそれが見えません
だから そういうやり方ではありません
こうする...ちょっと考えさせてください
そのため 作成しているゲームの種類や このアビリティの動作によっては ボタンを1回タップするとアビリティが起動して 実行中になることがあります
そして ダブルタップしてアビリティの 実行方法を変更したいかもしれません
そのようにしたいとしましょう
Wait Input Pressを押すと それはアビリティの アクティブ化のための入力ボタンが 2回目にトリガーされるのを待ちます
もし私が...ちょっと待って
別の方法としては 入力バッファリングシステムがあります
コンボシステムがあるとします
現在のところ ここで実装されている コンボシステムはとても力ずくです
これは 実際グレイストーンアセットに 付属しているデフォルトのコンボシステムで アニメーションモンタージュを プレイするだけでなく アビリティをアクティブ化するいくつかの 修正が加えられています
これは 攻撃入力をヒットした回数をカウントし 一定回数ループした後に リセットします
そのようにカウント数を管理できます
1回タップするとカウントは1になります
もう一度タップすると カウントが1に設定されている場合は 別のアビリティをトリガーします
メレーアクションゲームを作っているなら 私がやりたいと思う方法は 入力バッファリングシステムを作ることです
そこにゲームパッドの さまざまなボタン入力に対応する 列挙型変数を保存します
そして私は...
それらの入力が入力されるたびに 定期的に自身でクリアするリストの中に それらを記録します
これらのボタンを押すと x, y, a, bと押されたものすべてを このスタックのような形の シーケンシャルリストに記録します
それが何をするかというと これらの入力のリスト または入力の特定の順序によって アクティブ化されるアビリティのリストを持つ データテーブルをチェックします
したがって ダブルタップはx, xだけです
そこでそのデータテーブルを見ていき x, xを探します
それを入力バッファの内容と照合します
そしてその入力バッファの先頭で x, xに一致する入力があれば... いや それらが最新の2つの入力であれば このデータテーブルの中で それに対応するこのアビリティを アクティブ化したいのです
そうやって2回目のキー入力で 攻撃をするのです
そのシステムを管理する方法... これを作ったことがあります
Twitterで誰かがとても格好いい 入力バッファリングシステムを 作っているのを見てメモしました
その仕組みは 入力バッファをクリアするのに かかる時間をコントロールすることで 基本的にダブルタップの許容時間を コントロールできるということです
したがって 2秒間入力がないと入力バッファを クリアする場合は x, 1, xにできます
しかし 0.5秒間入力ない場合だと x, xとすれば おそらくうまくいくでしょう
xの後で間を置いてxを押すと x, xを探しません
xだけを探します
簡単にわかるといいのですが 見せずに話すのは少々厄介です

VICTOR:
最善を 尽くしているのは皆わかっています
theseedofjunaさんから 別の質問があります
続けて良ければ チームは続けられるので よければ質問を続けます

MICHAEL:
ええ 続けてください

VICTOR:
わかりました
はい 今年最も長いストリームになりそうです
では続けましょう
どのクラスで...今年の...
つまり新しい年です
とにかく 「AIでは どのクラスでASCを実装し ビヘイビアツリーの中でどのように ゲームプレイアビリティを呼ぶのでしょうか」

MICHAEL:
それはつまり... 既にあるかどうかは わかりませんが調べてみましょう
要するに AIタスクを作成することになります
これは通常のブループリントエディタを使って 行うのでしょうか
それとも... ああ それはビヘイビアツリーです
ビヘイビアツリーシステムは ゲームプレイアビリティシステムに 似た方法でタスクを使用します
これは AIに終了できる 現在アクティブなタスクという概念がある 理論に非常によく似ています
そしてそれが終了すると リストの次のタスクに移ります
このようにしてAIを特定のルーチンと 動作させることができます
見てみましょう
[入力中]「AITask」...「Task」
見てみましょう
BTTaskNode...
これはビヘイビアツリー用です
したがって デフォルトで作成されている タスクはあまりありません
ブループリントでタスクを作成できます

VICTOR:
KaosSpectrumさんを 呼ぶ必要があると思います
彼が答えを提供しています
こう言っています 「AIキャラクターでは ASCはキャラクター/ポーンに実装します アビリティをトリガーするには ゲームプレイタグを使用して タスクやサービスを介してそれを アクティブ化する必要があります これは最も一般的な方法の1つです」

MICHAEL:
はい
それがまさに私がお勧めする方法です
そう 単にアビリティタスクを作ります
Execute関数を得て

Try Activate Abilities by Tagとなります
そして 使用したいアビリティのタイプを含む ゲームプレイタグコンテナを与えます
これは汎用的なものにする方法でAIが... AIが自由に使えるメレーアビリティを 正確に知らなくても それを使えるようにするためのものです
アビリティが完了するのを リッスンするという点では イベントディスパッチャーか 何かがあるか見てみましょう
基本的に する必要があるのは...ええと... Finish Executeを呼び出すことです
これです...このアビリティが いつ終了するかに基づいています
Try Activate Abilities by Tagでいらだつのは これの追跡に使用できる AbilitySpecHandleを 出力しないことです
私がやる方法は これからAbilitySpecHandleを 得ることです
見てみましょう
「Try Activate Ability by Class」 これもAbilitySpecを 与えてくれないですね
しかし 私がするのは これが終了したときに イベントディスパッチャーに基づいて Finish Executeを 呼び出すために使用できる ハンドルを出力するものを作成することです
あるいは実際 考えてみると
ちょっと待って
これはいらない
もう1つの方法は おそらく AbilitySystemComponent内部にも 適用できるでしょう
AbilitySystemComponentを イベントディスパッチャーのホストにして それをした後 ここでFinish Executeを 実行することができます
AbilitySystemComponentは 何かが実行されたときに 起動される可能性があるため それを使用するのではなく アビリティ自体に基づいて行うようにします
この特定のアビリティが実行されたときに 起動するようにします

VICTOR:
それでは ak_themさんは
Daveも答えている質問をしています
「ゲームプレイ用のキューが...」
もう少しコーヒーが必要です
「ゲームプレイキューはNiagaraシステムに プログラムまたはリンクできますか？」

MICHAEL:
はい
ゲームプレイキューは 実際には ゲームプレイエフェクトがアクタに適用されたときに 何かを発生させるための 手段にすぎません
そこでゲームプレイキュー ダメージキュー ええ することは ロケーションで エミッタをスポーンするように指示し それにNiagaraシステムを渡します
するのはそれだけです
その後 他のパーティクルと同じように Niagaraシステムを起動します
ここにあるのは すべてグレイストーンパックに同梱されている レガシーパーティクルですが Niagaraでもこれができない理由は ありません
Niagaraシステムで 起きていることに基づいて ゲームプレイキューを 起動するという質問なら... Niagaraシステムがゲームプレイキューを 起動することは... それはかなり非公式だと思います

VICTOR:
Daveは それは実際には 不可能だと言っています

MICHAEL:
それは私が 望んでいることではありません...
望んだ動作ではありません
基本的には この流れを ゲームプレイアビリティが エフェクトを発生するようにしたいのです
エフェクトがゲームプレイキューの原因になる そうすべきなのです
それを駆動するのは...
犬が足に絡んできて話の 邪魔をしていて 集中できません
Douglas ハローは
いい子だ

VICTOR:
ハロー Douglas

MICHAEL:
いい子だ
しかし そう これの意図する流れは アビリティ エフェクト そしてキューであって アビリティ エフェクト キュー そしてキューがスポーンしたパーティクルなどに 基づく別のエフェクトではありません
パーティクルがエフェクトのエリアまたは 検出したいものと一致する場合は 完全なコスメティックなゲームプレイエフェクトを 作成し それをトリガーして... そのゲームプレイエフェクトを キャラクターに追加できます
そして そのゲームプレイエフェクトが 使いたいキューを持ちます

VICTOR:
これは ダブルタップ入力に関する質問に 関連する質問かもしれません
loraeshさんが尋ねています
「たとえば マーケットプレイスで グレイストーンと一緒に 提供されている 1、2、3メレー攻撃コンボは純粋な ゲームプレイアビリティシステムで どのように再現しますか？」

MICHAEL:
ええと それはここにあります
マーケットプレイスで配信している 1、2、3コンボを使っています
私がしたのは この実行を使って 彼がActivate Abilityで プレイしていたアニメーションモンタージュを 変えただけです
そして それに初期化したアビリティリストにある 彼のアビリティのインデックス番号を 入力しています
これらをアクティブ化するために やっているのはこれだけです
同様に 先ほど話した 入力バッファリングシステムを 使うこともできます
そして入力バッファリングシステム... それはユーザーが押した入力のリストを作るので ユーザはそれを使います
たとえば この入力文字列と一致した場合 最新の入力が この入力文字列と一致した場合 このアビリティを実行するよう指示するなど スイッチボードのような機能を作成します
そうすると 3ヒットコンボを 実行したい場合はxを入力します
それが最初の攻撃を実行します
x, xの入力があります それが2回目の攻撃を実行します
x, x, xの入力があり これが3番目の攻撃を実行します
これは非常に複雑な機能です
それは 後日 皆さんに デモしたいと思っています
しかし メレーアクションゲームや 格闘ゲームを作るとしたら これが私のやり方です
ゲームプレイアビリティを使用してやる場合は コンボの3つのヒットをすべて含むように ゲームプレイアビリティを設定することができます
ここでしているように それらを別々のアビリティにする 必要はありません
たまたまグレイストーンには 彼のメレー攻撃用に この3つのアニメーションモンタージュが 付属していて それらを別々に使うことができたのです
代わりにすることは アビリティを 有効にしてモンタージュをプレイするときに Start Sectionを指定します
あるセクションにはAttack1 別のセクションにはAttack2 別のセクションには Attack3を指定します
これらはすべて 3つのセクションに別れている1つの連続した アニメーションモンタージュに含まれます
モンタージュエディタで編集しているときは... これを使ったアニメーションもお見せします どこかな...ここの下までスクロールしないと グレイストーンまで行きます
えーと 攻撃A
彼は実際に3つの攻撃を 同時に持っているのかな？
彼は3つの攻撃を同時に持っているようには 見えませんが
そうすることもできます
そのようにサポートしたい場合は 完全なコンボを含むアニメーションを 1つのアニメーションモンタージュにまとめます
それから 入力に基づいて モンタージュの異なるセクションを トリガーするよう指示します
入力の確認は待たないかもしれません
これがボタン押し入力に 割り当てられていると... これはブループリントで使用しているのと同じ すべての入力イベントをリッスンできますが 割り当てられているものを 使用することをお勧めします
したがって Wait Input Press これを使って ここにCountを作ることができます
そして それが押されるたびにそれを使用して Switch on Intをします
そして これはAttack1につなぎます
これはAttack2につなぎます
これはAttack3につなぎます
以前の動作と同じように これがヒットした後 これが0に戻るようにします...
3になったとき そのように設定すると 少し余裕ができます
余裕
これがしたかったのではない
たぶん代わりにSequenceを使って...
少し整理します
では まずそれが3か調べます
その場合は Select
Countをここ
そして...これはしたかったことではない
これが欲しいノードです...
ブール値に基づくSelect Intです
ここでは安全を喫して 「それが3以上なら」とするべきです
3以上なら 0を選択します
それ以外の場合は 通常のカウントを維持しそれからその値を設定します

VICTOR:
質問に答えながら 取り組んできたこれらのことは [聴取不可]になると 思いますか？

MICHAEL:
ええ
私は消すつもりはありません
もちろん 教育用にとっておきます

VICTOR:
それが聞きたかったのです

MICHAEL:
はい これで増分します
この値が... 3以上の値になると ループして0に戻ります
それ以外の場合は その値を維持します
ここでしていることは おそらく非常に不器用な方法です
これをそのままコピーしておけば よかったのです
そして どのモンタージュを プレイするかを選択し
基本的にアクティブな間は たぶんリッスンしない... Attack1をリッスンしない方がいいでしょう
おそらく1と2だけを残したいでしょう
デフォルトでプレイするのはAttack1で Attack1がプレイし始めた後 Wait Input Pressで リッスンを開始し この出力ノード この出力ピンにつなぎます
そこでそれらの評価を始めます
ここでややこしいのは このEndAbilityノードに到達するまでの 実行の長さが 一定ではないことです
必要なのは... 終了したものと中断したものの違いが わかるようにする必要があります
これらの他のモンタージュのどれかがそれを 中断している場合 それを途中で終了させたくありません
これらのそれぞれが済んだ後 ちょっと待つこともできます
そして別の入力が入ったことを判断するために その待機をキャンセルすることもできます
これが 1つのアビリティの中に 完全なコンボをカプセル化する方法の例です

VICTOR:
では あと2つあります
まだ問題は残っていますが そのうちのいくつかを取り上げることにします
三時間を過ぎています
よくやりました Mike
そちらの部屋が 暗くなってきているのもわかります

MICHAEL:
はい
暗くなってきて 犬がお腹を空かせています

VICTOR:
うちのも同じです
loraeshさんが質問をしています
「ゲームプレイアトリビュートがデータテーブルから 初期化されるのを見たのは これが初めてでした 通常は ゲームプレイエフェクトが単に値を与え プレイ開始時などに自身に適用するために 使用されるのを見ました 当然どちらも機能しますが どちらの方法が望ましいのでしょうか？」

MICHAEL:
データテーブルが望ましいです
データテーブルまたは同様の方法を使用して 情報の出所を1か所にまとめます
ゲームプレイエフェクトを使用して それを初期化する場合は それらの値を変更したいたびに 個々のゲームプレイエフェクトをすべて編集して それらを変更する必要があります
また 必ずしもデザイナーが使いやすい方法で 公開されているわけではありません
データテーブルはデザイナーにとって 使いやすいものです
データテーブル...
Excelからデータテーブルをインポートできます
そのため これらのリポジトリを グーグルシートか どこかの安全なドライブに置くことができ デザイナーはエディタを開かなくても自由に 編集することができます
そして必要なときにそれらをインポートできます
そのため これらの初期化が はるかに柔軟になります

VICTOR:
データテーブルを使うと あらゆるものを管理するのがとても簡単です
すべてのキャラクターの全体像 武器が与えているダメージ 彼らのヘルス値 どれくらいの [聴取不可]があるかなどを把握できます
特に 代わりにそのような ものすべてを管理するために 個々のクラスを開いて プロデューサーの[聴取不可]を 設定するなどのことをするよりもはるかに 使いやすく作業しやすくなります

MICHAEL:
ええ 作るゲームの種類によっては 他の初期化方法が いいかもしれません
しかし そのようなデータテーブルで パラメータ化したり データ駆動型の管理方法があれば たとえパラゴンのように 信じられないほど洗練された 一連の状態値がすべてを動かしているような ゲームでなくても 仕事がやりやすくなります

VICTOR:
わかりました
では最後の質問です
Alexander Flodénさんは「ブループリントで 作成したプロトタイプアビリティを後で C++に移すのは簡単ですか それとも このシステムは非常にブループリント中心ですか？」 と尋ねています

MICHAEL:
ブループリントを使って アビリティタスクを操作することを想定しています
これが意図されたユースケースです
アビリティブループリントを作成し
グラフ内でタスクを操作して どのように実行したいかを判断します
これは アビリティのイテレーションを 非常に簡単にするためであり 極端に冗長にならないようにするためです
また タスクシステムを通じて すぐに取り出せる再利用可能な パーツを使って好きなアビリティを 作れるようにするためです
理論的には C++クラスでゲームプレイアビリティを発生させる ことができます
実際 理論的にではありません
デザイナーが操作できるようにしたい 定型関数を追加するには おそらくC++で 基本的なゲームプレイアビリティクラスを 派生させるとよいでしょう
また C++で個々のタスクごとに 定義されているステータス関数を使って アビリティタスクをそこにまとめることもできます
これは ノードネットワークを見るのと比べて アビリティタスクを調整する 非常に直感的な方法ではありません
そして重要なのはこれを簡潔にすることです

VICTOR:
これが最後だと 言いましたがもう1つあります
loraeshさんが尋ねています
「GASとアクタに組み込まれている ダメージ機能との間に公式な 相互作用はありますか？」

MICHAEL:
いいえ

VICTOR:
わかりました
それでは 本日はご参加いただき 誠にありがとうございました
長いストリームだったのはわかっています
多くのことを学んでいただけたら良いのですが
Mike 私たちの質問に詳しく 答えてくれてありがとう
その他の質問やフォローアップについては フォーラムのアナウンスポストを チェックするのを忘れないでください
Daveがいくつか答えたいと 言っていましたね
たぶん そこで彼からもう少し情報を 得られるでしょう
それをまたチャットに貼っておきましょう
そして 最初から私たちと 付き合っているのであれば 必ずTwitchでフォローしてください
私たちは毎週木曜日にライブ配信しています
ほぼ毎週木曜日です
年に何回はやっていませんが ほぼ毎週するようにしています
ゲーム開発を始めたばかりで Unreal Engineを 使い始めたいという方は 必ずunrealengine.comを チェックしてください
EngineはLauncherから無料でダウンロードできます
既にLauncherをインストールしていれば [Unreal Engine] タブに行って 入手してください
簡単です
私たちが紹介したものに興味があって その単語のスペルやグーグルで 何を探すのかわからない場合 私たちのライブストリームを すべてこのチャンネルで 文字起こししています
つまり通常はファイルが YouTubeにアップされてから 5～7日以内に 字幕用のファイルも提供します
これは ストリーム上でオンにできる字幕は YouTubeが自動的に 付ける字幕とは違って スペルも正確であることも意味します
Ctrl+Fを押して 探している単語を 検索するのも良い方法です
また 言文の横に タイムスタンプもあります
そこで何が語られているか もっと詳しく知りたければ ビデオのその部分に 行くことができます
すばらしいことにビデオにも タイムスタンプを入れています
Unreal Engineで作業するのが 好きな人を探したいなら communities.unrealengine.comを チェックしてみてください
ニュージーランドを除けば おそらくミートアップを行っているところは 世界中どこにもないでしょう
実際に確認したことはありません
おそらくするべきでしょう
そこでさえミートアップグループがあるか わかりません
しかし Discordなどで バーチャルなたまり場があるので ぜひチェックしてください
近くに地元のUE4コミュニティがなく パンデミックが収まったときに それらをホストすることを楽しみにしているなら 必ず記入してください...
そこにはコミュニティグループの リーダーになるための申請フォームがあります
前もってご連絡します
あなたが取り組んでいるすばらしいことを すべて教えてください
それにはいい場所がたくさんあります...
ツイッターのフォーラム UnrealSlackers.org 私たちは全部チェックしています
皆さんが何に取り組んでいるのか 見てみたいと思っていますし ときには ストリームの最初に コミュニティスポットライトの 一部として取り上げます
引き続きカウントダウンビデオを探しています
撮るのは30分の開発記録です
それを早送りして5に短縮し あなたのロゴと一緒にお送りください
こちらでその上にカウントダウンを 合成します
ロゴとビデオを別々にお願いします
Twitchでストリームする場合は 必ずUnreal Engineタグと Game Developmentタグを 使用してください
それが私たちだけでなく コミュニティの他の人たちにとっても あなたがライブ配信しているときに 見つける一番良い方法です
そして 今日 私たちは 誰かを訪問するつもりです
今ライブ配信している人を 何人か見たと思います
いつものように Unreal Engineに関するニュースは 必ずソーシャルメディアで フォローしてください
YouTubeでこれを見ているなら 通知ベルを押して 私たちのこれから出るクールなビデオを 見られるようにしてください
普及チームが今後数か月のうちに さらに多くのコンテンツを 発表する準備をしています Sjoerdさんのウォーターの解説を まだ見ていなければ 必ずチェックしてください
また Paoloさんの AIについての25分間のプレゼンテーション ステルスAI...驚異的です
そのようなことに興味があるなら 見てください

MICHAEL:
見てみないと

VICTOR:
ええ
最高です
来週は Movie Render Pipelineについて 詳しく説明します
トピックを出します
ああ書くのを忘れています
とにかく
Movie Render Pipelineです
Andy Blondinさん
Matt Hoffmanさん
Max Chenさんがストリームに登場します
それはすばらしいことになるでしょう
彼らに会うのが楽しみです
それについては これまで以上に 詳しく説明していきます
最後になりましたが Mike ストリームに来てくれて 本当にありがとうございました
二人とも犬が落ち着かなくなってきたので 外に連れて行かなければならないですね

MICHAEL:
どういたしまして
私がこのシステムを 理解する手助けをしてくれた チームの他のメンバーにも 感謝したいと思います
コメントしてくれたDave Rattiさんにも 感謝します
皆さん ありがとう
そして聴衆の皆さん ありがとうございました

VICTOR:
皆さんのおかげです
いつものように 来週の木曜日 東部時間の午後2時にお会いしましょう
安全な週末をお過ごしください
それでは 皆さん さようなら

```

---
