# System-MeleeAttack
アクションゲームでポピュラーに実装されている、連続入力で異なるモーションで攻撃を行う仕組みを実装する。

# 方法

大まかには以下の通り。

* 実装方針
	* 操作に関して
		* `コンボ入力可能期間`と `次の攻撃に移行可能期間`
			* この辺の基本的な考え方は [ヒストリア様のブログの 「[UE4]GameplayAbilitySystemでコンボ攻撃を作る」](https://historia.co.jp/archives/15422/) の実装方法と同じです。
				* ![](https://historia.co.jp/wp/wp-content/uploads/2020/05/Untitled-Diagram-1.png)
			* `コンボ入力可能期間`
				* モーション中、特定の期間で入力を受け付ける。
			* `次の攻撃に移行可能期間`
				* `コンボ入力可能期間` 中に入力が有った場合、 `次の攻撃に移行可能期間` に入った段階でアニメーションモンタージュのセクションジャンプを行う。
			* 上記の期間は AnimNotifyState で設定する。
			* 基本的には `コンボ入力可能期間` は `次の攻撃に移行可能期間` より早いタイミングで開始するように設定する。
				* そうすることで、先行入力できるようにする。
			* 上記２つの期間が重なってもよい。
				* 重なっている期間で入力が有った場合は即時アニメーションモンタージュのセクションジャンプを行う。
	* アニメーションモンタージュについて
		* 一つにまとめておくようにする。
			* [「UE4勉強会 in 大阪 - もっとアニメーションBP」](https://www.slideshare.net/com044/ue4-in-bp?qid=23d5e95d-5d4e-4d6b-b084-50083b994faf) の 48/49 ページ目。
				* ![](https://image.slidesharecdn.com/ue4osaka-mottoanimationbp-180519135544/95/ue4-in-bp-48-638.jpg?cb=1526738188)
				* ![](https://image.slidesharecdn.com/ue4osaka-mottoanimationbp-180519135544/95/ue4-in-bp-49-638.jpg?cb=1526738188)
			* こういう話もあったりしますが、今回の実装では一つにまとめます。
		* アニメーションモンタージュに攻撃に関する情報を置くようにする。
			* そうすることで、キャラクター毎に別のアニメーションモンタージュを用意することで GameplayAbility の実装を流用できるようにする。
	* ネットワーク対応について
		* 最低限、モーションと攻撃判定がネットワーク上で動作するように実装する。
		* 攻撃判定に関してはサーバーで完結するようにする。
			> note:
			> Rifle のようにクライアントで作成した TargetData をサーバーに渡すようにはしていない、ということです。
			> 操作感等を理由に Rifle のような処理にしたいのであれば、そちらの実装を参考にすると良いと思います。
		* `コンボ入力可能期間` の判定や先行入力状態の保持などに関してはクライアント側だけで処理する。
			* 要は入力を監視するための GameplayAbility の `Net Execution Policy` は `Local Only` にしておく。
			* そうすることで、ユーザーの過度の入力がネットワークの帯域に影響しないようにする。
* 上記の実装方針を基本とし、二種類の方法で実装してみます。
	* 方法１： GameplayAbility をなるべく少なくなるように実装する
	* 方法２： GameplayAbility の分割を制限せず、判定類をなるべく GameplayTag に頼るように実装する
* なぜ二種類か
	* アプローチの参考として二種類あげています。
	* ここで実装しているのはとてもシンプルな内容ですが、実際のゲームではもっと複雑な仕様となるはずですので、方法模索の一助となれば、と二種類挙げています。
		* ですので、これが絶対とか、正しいとかそういうものではありません。
* その他
	* 入力の割り当て
		* 方法１・２はそれぞれキーボードの 3 ・ 4 に割り当てます。
	* GameplayAbility の有効化の抑制
		* 方法１（２）の実行中に方法２（１）が実行できないようにしています。
		* 同様にジャンプ中は方法１・２が実行できないようにしています。
			* ジャンプしているかどうかの判定用の GameplayAbility も追加しています。
	* アセットの依存を減らす方策
		* 特に考慮していませんので、実用化する際は注意が必要です。
			* ブループリントクラスの派生やアセットの依存関係等。


以下、実装方法の説明となりますが、[大要] / [ソース毎の解説] と続きます。
[ソース毎の解説]は長くてくどいので、ソースを見てよくわからない場合に参考にする程度で良いと思います。


----

# 大要

## 命名規則関連

### ブループリントのフォルダ名について

関連ファイルはいくつかのフォルダに分かれて置いています。
フォルダごとの用途は以下の通り。

| フォルダ名   | 用途           |
| ------------ | -------------- |
| MeleeAttack  | 方法１・２共用 |
| MeleeAttack1 | 方法１専用     |
| MeleeAttack2 | 方法２専用     |

パスごとの用途は以下の通り。

| パス名                                                                | 用途             |
| --------------------------------------------------------------------- | ---------------- |
| Content/GASHandsOn/Core/AnimatonNotifies/MeleeAttack[12]*             | AnimNotify 用    |
| Content/GASHandsOn/Core/Characters/Heroes/Abilities/MeleeAttack[12]*  | Hero 専用        |
| Content/GASHandsOn/Core/Characters/Shared/Abilities/MeleeAttack[12]*  | キャラクター共用 |


### ブループリントのファイル名について

Hero 専用のファイルには `_Hero` のサフィックスをつけています。
（アニメーションモンタージュは例外で `AM_Hero_MeleeAttack[12]` となっています）
Hero 以外の操作キャラクターを追加する場合はこれらのファイルの `_Hero` 部分を変えて用意する想定です。


### GameplayTag の基本的なルール

| 階層名               | 用途                                               |
| -------------------- | -------------------------------------------------- |
| `Ability`            | AbilityTag で使用                                  |
| `Event`              | GameplayEvent で使用                               |
| `Loose`              | Loose に付与している                               |
| `Loose.Blocks`       | GameplayAbility の有効化を阻害するのに使用         |
| `Loose.MovementMode` | CharacterMovementComponent の MovementMode を示す  |

* Loose な GameplayTag とは
	* 自前で管理する必要がある、レプリケーションされない GameplayTag をそう呼んでいます。
		* 対称的に、 GameplayEffect で付与しているものは GameplayEffect により管理とレプリケーションが行われます。
	* 詳しくは [「GASDocumentation」の「4.2 Gameplay Tags」](https://github.com/tranek/GASDocumentation#concepts-gt) [（和訳）](https://github.com/sentyaanko/GASDocumentation/blob/lang-ja/README.jp.md#concepts-gt) を参照。


## 方法１・２共用

### 概要

* AbilitySystemComponent の拡張(C++)
	* AbilitySystemComponent 経由で再生したアニメーションモンタージュをセクションジャンプするための関数をブループリントに公開します。
		* 機能自体は `UAbilitySystemComponent` で用意されており、 [CurrentMontageJumpToSection] がそれにあたります。
		* ですが、ブループリントに公開はされていませんのでそれをラップした関数をブループリントに公開することで対応します。
* TargetData の自作(C++)
	* GameplayEventData に設定可能な TargetData を自作し、 GameplayEvent を送る際のパラメータとして利用します。
* CharacterMovementComponent の MovementMode の監視
	* キャラクターの移動状態の変化を監視する GameplayAbility を用意し、そこで状態を示す GameplayTag を設定することで、 GameplayAbility の有効化の抑制で利用できるようにします。


### GameplayTag 一覧

| 名前                         | 用途                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| `Loose.Blocks.Jump`          | Jump の抑制用                                                |
| `Loose.Blocks.MeleeAttack1`  | MeleeAttack1 の抑制用                                        |
| `Loose.Blocks.MeleeAttack2`  | MeleeAttack2 の抑制用                                        |
| `Loose.MovementMode.Walking` | CharacterMovementComponent の MovementMode が Walking を示す |


## 方法１

### 概要

* GameplayAbility は二つ使用します。
	* 一つは入力にバインドし、 `Send Gameplay Event` を呼び出す係です。
	* もう一つはその他の処理を行う係です。
		* キャラクター共通部分を基底クラスで作り、 Hero 専用部分を派生クラスで作るようにします。
		* Hero キャラクターへは派生クラスを登録します。
* AnimNotify では GameplayAbility の関数を直接呼び出しています。
	* つまりは GameplayEvent を使用しません。
	* Mesh → OwnerActor → AbilitySystemComponent → `Get Ability Instance from Class` → GameplayAbility のインスタンス、という順でアクセスしています。

### GameplayAbility 一覧

| 名前                       | 用途                                     | Character BP の Ability 登録 | Net Execution Policy |
| -------------------------- | ---------------------------------------- | ---------------------------- | -------------------- |
| [GA_MeleeAttack1Input]     | 入力バインド用。                         | する                         | Local Only           |
| [GA_MeleeAttack1Main]      | 入力以外の処理用。                       | しない                       | Local Predicted      |
| [GA_MeleeAttack1Main_Hero] | 上記の Hero 専用部分のオーバーライド用。 | する                         | Local Predicted      |

### AnimNotify 一覧

| 名前                              | 用途                                     | アニメーションモンタージュでの利用 |
| --------------------------------- | ---------------------------------------- | ---------------------------------- |
| [AN_MeleeAttack1HitBox]           | 攻撃判定通知用。                         | しない                             |
| [AN_MeleeAttack1HitBox_Hero]      | 上記の Hero 専用部分のオーバーライド用。 | する                               |
| [ANS_MeleeAttack1InputPermission] | コンボ入力可能状態の切り替え通知用。     | する                               |
| [ANS_MeleeAttack1JumpSection]     | ジャンプ先のセクション名通知用。         | する                               |

### GameplayTag 一覧

| 名前                                         | 用途          | 利用箇所                                                              | 詳細                                             |
| -------------------------------------------- | ------------- | --------------------------------------------------------------------- | ------------------------------------------------ |
| `Ability.Skill.MeleeAttack1.Input`           | AbilityTag    | [GA_MeleeAttack1Input]                                                |                                                  |
| `Ability.Skill.MeleeAttack1.Main`            | AbilityTag    | [GA_MeleeAttack1Main]                                                 |                                                  |
| `Event.MeleeAttack1.Input`                   | GameplayEvent | [GA_MeleeAttack1Input] (送信) / [GA_MeleeAttack1Main] (受信)          | 入力通知                                         |
| `Event.MeleeAttack1.Montage.SphereTrace`     | 特殊          | [GA_MeleeAttack1Main]                                                 | [EffectContainerMap] の として利用               |

* `Event.MeleeAttack1.Montage.SphereTrace` 
	* [EffectContainerMap] の Key として利用しています。
		* 通常、 [EffectContainerMap] は GameplayEvent で渡されたイベントタグを Key として使用します。
		* ですが、 [GA_MeleeAttack1Main] では GameplayEvent を経由しておらず、単に [EffectContainerMap] に関連した機能を利用するためだけにこの GameplayTag を使用しています。
		* そのため、 GameplayTag の命名規則に則していません。
			* 極端な話、こういった用途であれば `Ability` とかでも良いと思います（一つのファイルで完結しているため）。
		* 今回は方法２の `Event.MeleeAttack2.Montage.SphereTrace` と用途が近いため、そちらに合わせてこの名前を使用しています。

## 方法２

### 概要

* 各機能の抑制になるべく GameplayTag を利用します。
	* つまりは、各 GameplayAbility の有効化の抑制になるべく GameplayTag を利用する、ということです。
* GameplayAbility は五つ使用します。
* AnimNotify では「 GameplayTag の付与」または「 `Send Gameplay Event to Actor` による GameplayEvent の呼び出し 」 を行います。

### GameplayAbility 一覧

| 名前                              | 用途                                               | Character BP の Ability 登録 | Net Execution Policy |
| --------------------------------- | -------------------------------------------------- | ---------------------------- | -------------------- |
| [GA_MeleeAttack2First]            | 入力バインド用で、初撃用。                         | する                         | Local Only           |
| [GA_MeleeAttack2Combo]            | 入力バインド用で、二撃目以降用。                   | する                         | Local Only           |
| [GA_MeleeAttack2PlayMontage]      | アニメーションモンタージュの再生用。               | しない                       | Local Prediction     |
| [GA_MeleeAttack2PlayMontage_Hero] | 上記の Hero 専用部分のオーバーライド用。           | する                         | Local Prediction     |
| [GA_MeleeAttack2Damage]           | ダメージ処理用。                                   | しない                       | Server Only          |
| [GA_MeleeAttack2Damage_Hero]      | 上記の Hero 専用部分のオーバーライド用。           | する                         | Local Only           |
| [GA_MeleeAttack2JumpSection]      | アニメーションモンタージュのセクションジャンプ用。 | する                         | Local Only           |

### AnimNotify 一覧

| 名前                                               | 用途                                                  | アニメーションモンタージュでの利用 |
| -------------------------------------------------- | ----------------------------------------------------- | ---------------------------------- |
| [ANS_AddLooseGameplayTagsIfOwnerLocallyControlled] | 汎用だが、コンボ入力可能状態の切り替え通知で利用。    | する                               |
| [AN_MeleeAttack2HitBox]                            | 攻撃判定通知用。                                      | しない                             |
| [AN_MeleeAttack2HitBox_Hero]                       | 上記の Hero 専用部分のオーバーライド用。              | する                               |
| [ANS_MeleeAttack2JumpSection]                      | ジャンプ先のセクション名通知用。                      | する                               |

### GameplayTag 一覧

| 名前                                         | 用途          | 利用箇所                                                                    | 詳細                                             |
| -------------------------------------------- | ------------- | --------------------------------------------------------------------------- | ------------------------------------------------ |
| `Ability.Skill.MeleeAttack2.First`           | AbilityTag    | [GA_MeleeAttack2First]                                                      |                                                  |
| `Ability.Skill.MeleeAttack2.Combo`           | AbilityTag    | [GA_MeleeAttack2Combo]                                                      |                                                  |
| `Ability.Skill.MeleeAttack2.PlayMontage`     | AbilityTag    | [GA_MeleeAttack2PlayMontage]                                                |                                                  |
| `Ability.Skill.MeleeAttack2.JumpSection`     | AbilityTag    | [GA_MeleeAttack2JumpSection]                                                |                                                  |
| `Ability.Skill.MeleeAttack2.Damage`          | AbilityTag    | [GA_MeleeAttack2Damage]                                                     |                                                  |
| `Event.MeleeAttack2.PlayMontage`             | GameplayEvent | [GA_MeleeAttack2First] (送信) / [GA_MeleeAttack2PlayMontage] (受信)         | アニメーションモンタージュの再生要求             |
| `Event.MeleeAttack2.EndMontage`              | GameplayEvent | [GA_MeleeAttack2PlayMontage] (送信) / [GA_MeleeAttack2First] (受信)         | アニメーションモンタージュの終了通知             |
| `Event.MeleeAttack2.Montage.JumpSection`     | GameplayEvent | [ANS_MeleeAttack2JumpSection] (送信) / [GA_MeleeAttack2JumpSection] (受信)  | セクションジャンプの入力監視開始要求             |
| `Event.MeleeAttack2.Montage.SphereTrace`     | GameplayEvent | [AM_Hero_MeleeAttack2] (送信) / [GA_MeleeAttack2Damage] (受信)              | 攻撃判定要求                                     |
| `Loose.MeleeAttack2.RunningFirst`            | GA起動条件用  | [GA_MeleeAttack2First] (write) / [GA_MeleeAttack2Combo] (read)              | [GA_MeleeAttack2First] が実行中であることを示す  |
| `Loose.MeleeAttack2.EnableComboInput`        | GA起動条件用  | [AM_Hero_MeleeAttack2] (write) / [GA_MeleeAttack2Combo] (read)              | `コンボ入力可能期間` であることを示す            |
| `Loose.MeleeAttack2.EnableComboJumpSection`  | GA起動条件用  | [AM_Hero_MeleeAttack2] (write) / [GA_MeleeAttack2JumpSection] (read)        | `次の攻撃に移行可能期間` であることを示す        |
| `Loose.MeleeAttack2.PushedCombo`             | フラグ        | [GA_MeleeAttack2Combo] (write) / [GA_MeleeAttack2JumpSection] (read)        | コンボ入力があったことを示すフラグ用             |


----

# ソース毎の解説

## C++

### [ActionRPG] の機能解説

Epic のサンプルである [ActionRPG] 内で実装されている以下の機能について軽く補足します。（型名のプレフィックスは変わっています）
* GameplayAbility の拡張で追加されたメンバ変数 [EffectContainerMap]
* [EffectContainerMap] の宣言で利用される型 [UGHOTargetType] / [FGHOGameplayEffectContainer]
* GameplayAbility の拡張で追加されたメンバ関数 [MakeEffectContainerSpec] / [ApplyEffectContainerSpec]

詳しくは [「GASDocumentation」の「4.5.18 Gameplay Effect Containers」](https://github.com/tranek/GASDocumentation#concepts-ge-containers) [（和訳）](https://github.com/sentyaanko/GASDocumentation/blob/lang-ja/README.jp.md#concepts-ge-containers) を参照。

> note:
> この仕組みは [GASShooter] / [GAS Companion] にも取り込まれています。
> [GASDocumentation] では利用しなかった場合を例を示すためにあえて取り込んでいないそうです。
> （前述のリンク先で言及されています）

#### EffectContainerMap

 [EffectContainerMap] は GameplayAbility クラス内で以下のように宣言されています。

 ```c++
// UGHOGameplayAbility の宣言より
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GASHandsOn|GameplayEffects")
 	TMap<FGameplayTag, FGHOGameplayEffectContainer> EffectContainerMap;

```

#### FGHOGameplayEffectContainer

[FGHOGameplayEffectContainer] は以下のように宣言されています。

```c++
USTRUCT(BlueprintType)
struct FGHOGameplayEffectContainer
{
	GENERATED_BODY()

	FGHOGameplayEffectContainer() {}

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GASHandsOn|GameplayEffectContainer")
	TSubclassOf<UGHOTargetType> TargetType;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GASHandsOn|GameplayEffectContainer")
	TArray<TSubclassOf<UGameplayEffect>> TargetGameplayEffectClasses;
};

```

#### UGHOTargetType

[UGHOTargetType] は以下のように宣言されています。

```c++
UCLASS(Blueprintable, meta = (ShowWorldContextPin))
class GASHANDSON_API UGHOTargetType : public UObject
{
	GENERATED_BODY()

public:
	UGHOTargetType() {}

	UFUNCTION(BlueprintNativeEvent, Category = "GASHandsOn")
	void GetTargets(AGHOCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray<FGameplayAbilityTargetDataHandle>& OutTargetData, TArray<FHitResult>& OutHitResults, TArray<AActor*>& OutActors) const;
	virtual void GetTargets_Implementation(AGHOCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray<FGameplayAbilityTargetDataHandle>& OutTargetData, TArray<FHitResult>& OutHitResults, TArray<AActor*>& OutActors) const;
};

```

#### MakeEffectContainerSpec

[MakeEffectContainerSpec] は GameplayAbility クラス内で以下のように宣言されています。

```c++
// UGHOGameplayAbility の宣言より
	UFUNCTION(BlueprintCallable, Category = "GASHandsOn|Ability", meta = (AutoCreateRefTerm = "EventData"))
	FGHOGameplayEffectContainerSpec MakeEffectContainerSpec(FGameplayTag ContainerTag, const FGameplayEventData& EventData, int32 OverrideGameplayLevel = -1);

```

引数と [EffectContainerMap] を元に、 [ApplyEffectContainerSpec] に渡すことで適用可能な処理済みの GameplayEffect のデータ `FGHOGameplayEffectContainerSpec` を生成します。

#### ApplyEffectContainerSpec

[ApplyEffectContainerSpec] は GameplayAbility クラス内で以下のように宣言されています。

```c++
// UGHOGameplayAbility の宣言より
	UFUNCTION(BlueprintCallable, Category = "GASHandsOn|Ability")
	TArray<FActiveGameplayEffectHandle> ApplyEffectContainerSpec(const FGHOGameplayEffectContainerSpec& ContainerSpec);

```

引数を元に、GameplayEffect を適用します。


#### [ActionRPG] の機能解説のまとめ

まとめると以下のようになります。

* [UGHOTargetType] は対象を動的に収集する関数 `GetTargets()` を備えたクラス
	* これを利用することで GameplayEffect の適用対象を収集するコードを GameplayAbility から分離し再利用出来るようにし、また GameplayAbility ロジックをシンプルに保つことができます。
* [FGHOGameplayEffectContainer] は対象 (`TargetType`) と効果 (`GameplayEffect`) を設定できる構造体
* [EffectContainerMap] は GameplayTag を Key に、対象と効果を Value に設定できる GameplayAbility のメンバ変数
* [MakeEffectContainerSpec] は GameplayTag と GameplayEventData を元に `FGHOGameplayEffectContainerSpec` を生成する GameplayAbility のメンバ関数
* [ApplyEffectContainerSpec] は `FGHOGameplayEffectContainerSpec` を元に GameplayEffect を適用する GameplayAbility のメンバ関数


> note: `ApplyEffectContainer`
> [ActionRPG] / [GAS Companion] では [MakeEffectContainerSpec] / [ApplyEffectContainerSpec] を一気に行う関数 `ApplyEffectContainer` も用意されています。
> このプロジェクトでは（ [GASShooter] を元にしているのあり ）用意していません。
> [MakeEffectContainerSpec] / [ApplyEffectContainerSpec] をつなげるだけの実装が多い場合は `ApplyEffectContainer` の実装を検討しても良いと思います。
> 個別の関数を使うメリットは、適用前に `SetByCaller` によるパラメータ設定など、 GameplayEffect 適用前の加工が行えることです。

利用シーンについては以下のようになります。

* GameplayEvent で利用
	* GameplayEvent の `EventTag` を [EffectContainerMap] の Key として利用することが可能です。
* 固定の GameplayTag で利用
	* GameplayEvent は使用せず、固定の GameplayTag を Key として利用することも可能です。
	* 方法１の攻撃判定でこの方法を利用しています。


### [GASShooter] の機能拡張

[GASShooter] で実装されている機能の一部を拡張していますので、その解説を行います。

* [FindAbilitySpecFromClassWithAllowInheritedTypeFlag] 関数の新規作成
	* ブループリントに公開しておらず、 [GetPrimaryAbilityInstanceFromClass] からのみ利用しています。
* [GetPrimaryAbilityInstanceFromClass] 関数の引数追加
	* 方法１において、 AnimNotify から GameplayAbility の関数呼び出しを行う際に利用しています。


#### FindAbilitySpecFromClassWithAllowInheritedTypeFlag

[FindAbilitySpecFromClassWithAllowInheritedTypeFlag] は `UAbilitySystemComponent` で宣言されている関数 `FindAbilitySpecFromClass` を拡張したものです。

```c++
//AbilitySystemComponent.h
	/** Returns an ability spec corresponding to given ability class. If modifying call MarkAbilitySpecDirty */
	FGameplayAbilitySpec* FindAbilitySpecFromClass(TSubclassOf<UGameplayAbility> InAbilityClass);
```

この関数は `AbilitySystemComponent` が保持する `FGameplayAbilitySpec` の中で、渡された `InAbilityClass` が一致するものを返す関数です。
これを拡張し、渡された `InAbilityClass` が Is-A 関係のものも返す関数 [FindAbilitySpecFromClassWithAllowInheritedTypeFlag] を新規作成しました。

```c++
//GHOAbilitySystemComponent.h
	FGameplayAbilitySpec* FindAbilitySpecFromClassWithAllowInheritedTypeFlag(TSubclassOf<UGameplayAbility> InAbilityClass, bool bAllowInheritedType);

//GHOAbilitySystemComponent.cpp
FGameplayAbilitySpec* UGHOAbilitySystemComponent::FindAbilitySpecFromClassWithAllowInheritedTypeFlag(TSubclassOf<UGameplayAbility> InAbilityClass, bool bAllowInheritedType)
{
	auto l = bAllowInheritedType ?
		std::function<bool(UGameplayAbility*)>{ [&InAbilityClass](UGameplayAbility* a) {return a->IsA(InAbilityClass); }} :
		std::function<bool(UGameplayAbility*)>{ [&InAbilityClass](UGameplayAbility* a) {return a->GetClass() == InAbilityClass; } };
	for (FGameplayAbilitySpec& Spec : ActivatableAbilities.Items)
	{
		if (l(Spec.Ability))
		{
			return &Spec;
		}
	}

	return nullptr;
}

```

#### GetPrimaryAbilityInstanceFromClass

引数 `bAllowInheritedType` を追加し、 Is-A 関係のものも返すかを指定できるようにしました。
`FindAbilitySpecFromClass` の代わりに [FindAbilitySpecFromClassWithAllowInheritedTypeFlag] を呼び出すように実装を変更しています。

```c++
//GHOBlueprintFunctionLibrary.h
	UFUNCTION(BlueprintCallable, Category = "GASHandsOn|Ability")
	static UGHOGameplayAbility* GetPrimaryAbilityInstanceFromClass(UAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<UGameplayAbility> InAbilityClass, bool bAllowInheritedType);

//GHOBlueprintFunctionLibrary.cpp
UGHOGameplayAbility* UGHOBlueprintFunctionLibrary::GetPrimaryAbilityInstanceFromClass(UAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<UGameplayAbility> InAbilityClass, bool bAllowInheritedType)
{
	//if (AbilitySystemComponent) //original code
	if (UGHOAbilitySystemComponent* ASC = Cast<UGHOAbilitySystemComponent>(AbilitySystemComponent))
	{
		//if (FGameplayAbilitySpec* AbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(InAbilityClass)) //original code
		if (FGameplayAbilitySpec* AbilitySpec = ASC->FindAbilitySpecFromClassWithAllowInheritedTypeFlag(InAbilityClass, bAllowInheritedType))
		{
			return Cast<UGHOGameplayAbility>(AbilitySpec->GetPrimaryInstance());
		}
	}

	return nullptr;
}

```

> note: 作成した理由について
> 一部の GameplayAbility クラスは、キャラクターに依らない共通部分を実装している基底クラスと、キャラクター毎に異なる実装している派生クラスに分けて作成しています。
> （例：[GA_MeleeAttack1Main] と [GA_MeleeAttack1Main_Hero]）
> AnimNotify からの GameplayAbility クラスの関数呼び出しは基底側で定義したものを想定していますが、 AbilitySystemComponent が所持しているのは派生クラスとなります。
> そのため、拡張を行わないと、 AnimNotify 内で派生クラスのクラス型を指定する必要がありました。
> * 拡張前
> 	* [GetPrimaryAbilityInstanceFromClass] の際に派生クラスの指定が（ AnimNotify では派生クラスの機能を使用していないのに）必要だった。
> 	* AnimNotify から派生クラスへのオブジェクト参照も発生していた。
> * 拡張後
> 	* [GetPrimaryAbilityInstanceFromClass] の際に基底クラスの指定で良くなり、派生クラスの指定が不要になった。
> 	* AnimNotify から派生クラスへのオブジェクト参照がなくなった。（基底クラスへのオブジェクト参照は（取得後に基底クラスへのキャストを行う必要があるため）もともと必要）


### CurrentMontageJumpToSection

`UAbilitySystemComponent::CurrentMontageJumpToSection()` をブループリントから利用するための関数を実装する。

> note: `UAbilitySystemComponent::CurrentMontageJumpToSection()`
> AbilityTask `Play Montage and Wait` / `Play Montage and Wait for Event` 等でアニメーションモンタージュの再生中に呼び出すことで、指定したセクションにジャンプできる。
> 呼び出しはクライアント側で行うことが想定されている。
> 関数内で RPC の呼び出しが行われ、サーバーにセクションジャンプの実行をリクエストする。
> サーバーは RPC を受け取りセクションジャンプ可能ならば他のクライアントにも（アニメーションモンタージュの情報を保持する `UAbilitySystemComponent::RepAnimMontageInfo` のレプリケーションを通じて）伝達する。


```c++
//GHOAbilitySystemComponent.h
	UFUNCTION(BlueprintCallable, Category = "GASHandsOn|Abilities", meta = (DisplayName = "CurrentMontageJumpToSection"))
	void K2_CurrentMontageJumpToSection(FName SectionName);


//GHOAbilitySystemComponent.cpp
void UGHOAbilitySystemComponent::K2_CurrentMontageJumpToSection(FName SectionName)
{
	CurrentMontageJumpToSection(SectionName);
}
```


### UGHOHitResultFilterType

このクラスは HitResults をフィルタリングすることで別の HitResults を作成するための基底クラスです。
SphereTrace などで取得した HitResults のフィルターを行うことを想定しています。
具体的なフィルター内容はブループリントクラスで実装することを想定しています。

> note:
> 今回は派生クラス [HitResultFilterType_Nearest] を作成しています。
> そこでは HitResults に同一のアクターが複数含まれている場合は、判定の開始地点から最も近いもののみ残すような処理を実装しています。
> これは、攻撃のヒットボックスとして SphereTrace を使っていますが、複数回命中しても一回だけダメージが発生するようにしたかったのでこのような機能を実装しています。
> （拡張例として、部位ごとにダメージが発生するようにしたり、一番ダメージが大きくなる弱点部位だけにダメージが発生するよう等も可能だと思います。）


HitResults を加工する作りにしているので、 HitResults さえあれば使用できるため、他の Trace 関数等でも利用できます。
今回は SphereTrace を使用することを含めて攻撃判定処理全般が暫定のため、このような形にしています。
（別のアプローチとして、攻撃判定専用の Trace 処理を独自に実装して、任意の HitResults を生成する等も可能だと思います。）

```c++
//GHOTargetTypes.h
/*
	SphereTrace などで取得した HitResults をフィルターを行う基底クラス
*/
UCLASS(Blueprintable)
class GASHANDSON_API UGHOHitResultFilterType : public UObject
{
	GENERATED_BODY()

public:
	// Constructor and overrides
	UGHOHitResultFilterType() {}

	/*
	*/
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "GASHandsOn")
	void FilterHitResults(TArray<FHitResult>& OutHitResults, UPARAM(ref) TArray<FHitResult>& InHitResults) const;
	virtual void FilterHitResults_Implementation(TArray<FHitResult>& OutHitResults, UPARAM(ref) TArray<FHitResult>& InHitResults) const;
};

//GHOTargetTypes.cpp
void UGHOHitResultFilterType::FilterHitResults_Implementation(TArray<FHitResult>& OutHitResults, TArray<FHitResult>& InHitResults)const
{
	return;
}

```


### FGameplayAbilityTargetData_Int32

GameplayEventData の TargetData に設定可能な `FGameplayAbilityTargetData` 派生構造体です。
int32 を内包した汎用的なターゲットデータです。
これを利用することで、 int32 のパラメータを持った GameplayEvent を GameplayAbility に送ることができます。

攻撃の種類を GameplayAbility に渡すのに利用しています。

> note: `FGameplayAbilityTargetData` （ TargetData 、ターゲットデータ）
> [GASHandsOn の 0.1.7.System-Weapon.md](https://github.com/sentyaanko/GASHandsOn/blob/main/Documents/0.1.7.System-Weapon.md#fgameplayabilitytargetdata) のヘッダコメントの和訳がありますので基本的なことはそちらを参照。
> `FGameplayAbilityTargetData` の派生構造体は `Send Gameplay Event` / `Send Gameplay Event to Actor` のパラメータとして利用できます。
> ですが、ブループリントからはこれらの構造体に直接アクセスしません。
> 「構造体に内包させる値を受け取りハンドルを返却する関数」と、「そのハンドルを受け取り内包する値を返却する関数」を [UGHOBlueprintFunctionLibrary] で作成します。
> GameplayEvent 送信側は前者を、 GameplayEvent 受信側は後者を利用してパラメータの受け渡しを行います。
> （エンジンで用意されているものがそうなっているので、今回作成しているものもそれに合わせています。）

> note: NetSerialize
> `FGameplayAbilityTargetData` 派生構造体でそれ関連のコードがあります。
> 触ったことがない場合は、 [ここ](http://www.aclockworkberry.com/custom-struct-serialization-for-networking-in-unreal-engine/) とか見ると良いです。
> ただ、現状では、 [FGameplayAbilityTargetData_Int32] / [FGameplayAbilityTargetData_Name] をネットワーク経由で送っていません。（そのため、TypeTraits の WithNetSerializer も false にしています。）
> というのも、これらは、起動中の GameplayAbility の AbilityTask `Wait Gameplay Event` での GameplayEvent 待ちに対して `Send Gameplay Event to Actor` しています。
> この方法の場合、 GameplayEvent の発生はレプリケーションされません。
> 詳しくは [「GASDocumentation」の「4.6.11 Passing Data to Abilities」](https://github.com/tranek/GASDocumentation#concepts-ga-data) [（和訳）](https://github.com/sentyaanko/GASDocumentation/blob/lang-ja/README.jp.md#concepts-ga-data) を参照。


```c++
//GHOTargetData_Int32.h
USTRUCT()
struct GASHANDSON_API FGameplayAbilityTargetData_Int32: public FGameplayAbilityTargetData
{
	GENERATED_BODY()

	FGameplayAbilityTargetData_Int32()
		: Value(0)
	{
	}
	virtual ~FGameplayAbilityTargetData_Int32() {};

	void operator=(const FGameplayAbilityTargetData_Int32& rhs)
	{
		Value = rhs.Value;
	}

	// begin FGameplayAbilityTargetData interface
	/*
	by Epic
		Returns the serialization data, must always be overridden
	*/
	virtual UScriptStruct* GetScriptStruct() const override
	{
		return FGameplayAbilityTargetData_Int32::StaticStruct();
	}

	/*
	by Epic
		Returns a debug string representation
	*/
	virtual FString ToString() const override
	{
		return TEXT("FGameplayAbilityTargetData_Int32");
	}

	// end FGameplayAbilityTargetData interface

	bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess);


	UPROPERTY()
	int32 Value;
	
};


template<>
struct TStructOpsTypeTraits<FGameplayAbilityTargetData_Int32> : public TStructOpsTypeTraitsBase2<FGameplayAbilityTargetData_Int32>
{
	enum
	{
		WithNetSerializer              = false,                         // by Epic: struct has a NetSerialize function for serializing its state to an FArchive used for network replication.
		WithCopy                       = true                           // by Epic: struct can be copied via its copy assignment operator.
	};
};

//GHOTargetData_Int32.cpp
bool FGameplayAbilityTargetData_Int32::NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess)
{
	Ar << Value;
	bOutSuccess = true;
	return true;
}
```

### FGameplayAbilityTargetData_Name

GameplayEventData の TargetData に設定可能な `FGameplayAbilityTargetData` 派生構造体です。
FName を内包した汎用的なターゲットデータです。
これを利用することで、 FName のパラメータを持った GameplayEvent を GameplayAbility に送ることができます。

`次の攻撃に移行可能期間` に入った際にジャンプ先のセクション名を GameplayAbility に渡すのに利用しています。


```c++
//GHOTargetData_Name.h
USTRUCT()
struct GASHANDSON_API FGameplayAbilityTargetData_Name : public FGameplayAbilityTargetData
{
	GENERATED_BODY()

	FGameplayAbilityTargetData_Name()
		: Value()
	{
	}
	virtual ~FGameplayAbilityTargetData_Name() {};

	void operator=(const FGameplayAbilityTargetData_Name& rhs)
	{
		Value = rhs.Value;
	}

	// begin FGameplayAbilityTargetData interface
	/*
	by Epic
		Returns the serialization data, must always be overridden
	*/
	virtual UScriptStruct* GetScriptStruct() const override
	{
		return FGameplayAbilityTargetData_Name::StaticStruct();
	}

	/*
	by Epic
		Returns a debug string representation
	*/
	virtual FString ToString() const override
	{
		return TEXT("FGameplayAbilityTargetData_Name");
	}

	// end FGameplayAbilityTargetData interface

	bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess);


	UPROPERTY()
	FName Value;
	
};


template<>
struct TStructOpsTypeTraits<FGameplayAbilityTargetData_Name> : public TStructOpsTypeTraitsBase2<FGameplayAbilityTargetData_Name>
{
	enum
	{
		WithNetSerializer              = false,                         // by Epic: struct has a NetSerialize function for serializing its state to an FArchive used for network replication.
		WithCopy                       = true                           // by Epic: struct can be copied via its copy assignment operator.
	};
};

//GHOTargetData_Name.cpp
bool FGameplayAbilityTargetData_Name::NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess)
{
	Ar << Value;
	bOutSuccess = true;
	return true;
}
```

### UGHOBlueprintFunctionLibrary

[FGameplayAbilityTargetData_Int32] / [FGameplayAbilityTargetData_Name] のハンドル `FGameplayAbilityTargetDataHandle` を生成する関数と
`FGameplayAbilityTargetDataHandle` から [FGameplayAbilityTargetData_Int32] / [FGameplayAbilityTargetData_Name] 内の int32 / FName を引き出すための関数を宣言しています。

```c++
//GHOBlueprintFunctionLibrary.h
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GASHandsOn|Ability|TargetData")
	static FGameplayAbilityTargetDataHandle	AbilityTargetDataFromInt32(int32 Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GASHandsOn|Ability|TargetData")
	static FGameplayAbilityTargetDataHandle	AbilityTargetDataFromName(FName Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GASHandsOn|Ability|TargetData")
	static int32 GetInt32FromTargetData(const FGameplayAbilityTargetDataHandle& TargetData, int32 Index);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GASHandsOn|Ability|TargetData")
	static FName GetNameFromTargetData(const FGameplayAbilityTargetDataHandle& TargetData, int32 Index);

//GHOBlueprintFunctionLibrary.cpp
FGameplayAbilityTargetDataHandle UGHOBlueprintFunctionLibrary::AbilityTargetDataFromInt32(int32 Value)
{
	// Construct TargetData
	FGameplayAbilityTargetData_Int32*	NewData = new FGameplayAbilityTargetData_Int32();
	NewData->Value = Value;

	// Give it a handle and return
	FGameplayAbilityTargetDataHandle	Handle;
	Handle.Data.Add(TSharedPtr<FGameplayAbilityTargetData_Int32>(NewData));
	return Handle;
}

FGameplayAbilityTargetDataHandle UGHOBlueprintFunctionLibrary::AbilityTargetDataFromName(FName Value)
{
	// Construct TargetData
	FGameplayAbilityTargetData_Name*	NewData = new FGameplayAbilityTargetData_Name();
	NewData->Value = Value;

	// Give it a handle and return
	FGameplayAbilityTargetDataHandle	Handle;
	Handle.Data.Add(TSharedPtr<FGameplayAbilityTargetData_Name>(NewData));
	return Handle;
}

int32 UGHOBlueprintFunctionLibrary::GetInt32FromTargetData(const FGameplayAbilityTargetDataHandle& TargetData, int32 Index)
{
	if (TargetData.Data.IsValidIndex(Index))
	{
		if (auto Data = TargetData.Data[Index].Get())
		{
			if (Data->GetScriptStruct()->IsChildOf(FGameplayAbilityTargetData_Int32::StaticStruct()))
			{
				auto p = static_cast<FGameplayAbilityTargetData_Int32*>(Data);
				return p->Value;
			}
		}
	}

	return 0;
}

FName UGHOBlueprintFunctionLibrary::GetNameFromTargetData(const FGameplayAbilityTargetDataHandle& TargetData, int32 Index)
{
	if (TargetData.Data.IsValidIndex(Index))
	{
		if (auto Data = TargetData.Data[Index].Get())
		{
			if (Data->GetScriptStruct()->IsChildOf(FGameplayAbilityTargetData_Name::StaticStruct()))
			{
				auto p = static_cast<FGameplayAbilityTargetData_Name*>(Data);
				return p->Value;
			}
		}
	}

	return FName();
}

```

## ブループリント

### 方法１・２共通

| ファイル名                                         | 分類                  | 用途              |
| -------------------------------------------------- | --------------------- | ----------------- |
| [ANS_AddLooseGameplayTagsIfOwnerLocallyControlled] | AnimNotifyState       | キャラクター共用  |
| [GA_MovementMode]                                  | GameplayAbility       | キャラクター共用  |
| [GA_CharacterJump]                                 | GameplayAbility       | キャラクター共用  |
| [AttackParameterType]                              | Struct                | キャラクター共用  |
| [GE_MeleeAttackDamage]                             | GameplayEffect        | キャラクター共用  |
| [TargetType_SphereTrace]                           | [TargetType]          | キャラクター共用  |
| [HitResultFilterType_Nearest]                      | [HitResultFilterType] | キャラクター共用  |
| [EMeleeAttackType_Hero]                            | Enum                  | Hero 用           |
| [TargetType_MeleeAttack_Hero]                      | [TargetType]          | Hero 用           |


#### ANS_AddLooseGameplayTagsIfOwnerLocallyControlled

`IsLocallyControlled` を使用して、自身で操作している Actor の場合のみ、 Loose な GameplayTag を付与する、汎用的な AnimNotifyState です。


#### GA_MovementMode

移動状態を監視する GameplayAbility です。

* `CharacterMovementComponent` が所持する `MovementMode` を示す GameplayTag を Loose に付与します。
* Loose に付与しているのは、 GameplayAbility の入力による起動を抑制するのに使用しているため、レプリケーションする意味がないからです。


#### GA_CharacterJump

既に実装していた `GHOGA_CharacterJump` の派生クラスです。

* `Activation Blocked Tags` で `Loose.Blocks.Jump` を指定することで、他の GameplayAbility が Jump の有効化を阻害できるようにしています。


#### AttackParameterType

攻撃時の HitBox に関する構造体です。
この実装では SpereTrace により判定しているため、それに関する情報を持っています。

* TraceLength: トレース距離
* TraceRadius: 半径
* SocketName: 起点となるソケット名

[TargetType_SphereTrace] でこの型を利用しています。
また、その派生クラスである [TargetType_MeleeAttack_Hero] がデータ本体を持っています。


#### GE_MeleeAttackDamage

ダメージ用の GameplayEffect です。
今回は、実装済みの Rifle 等と同じ内容です。


#### TargetType_SphereTrace

[UGHOTargetType] 派生クラスです。

GameplayEventData の TargetData 経由で攻撃の種類を受け取り、それを元に SphereTrace を実行し、更に HitResults の加工を行っています。

1. `GetTargets` で受け取った GameplayEventData を `GetAttackParameter` に渡し、使用すべき [AttackParameterType] を取得します。
	* `GetAttackParameter` はキャラクター毎に異なる値を使用できるよう、派生クラスで実装することを想定しています。
2. [AttackParameterType] を元に `MultiSphereTraceForObjects` を実行して HitResults を取得します。
3. [AttackParameterType] で指定された [HitResultFilterType] を生成し、 `FilterHitResults` で加工します。
	* 加工方法を指定する [HitResultFilterType] も [AttackParameterType] を含めることで、攻撃毎に異なるフィルターを指定できるようにしています。

#### HitResultFilterType_Nearest

[UGHOHitResultFilterType] の派生クラスです。

HitResults 内に同一のアクターの情報が有った場合、起点となるソケットに最も近い情報だけ残して他は削除するフィルター処理を行います。


#### EMeleeAttackType_Hero

Hero の攻撃の種類を示す enum です。

データの種類や仕様が確定していない段階なので、攻撃の種類に enum を利用することで、データの増減や名前変更に追従しやすいようにしています。


#### TargetType_MeleeAttack_Hero

[TargetType_SphereTrace] 派生クラスです。

`GetAttackParameter` をオーバーライドすることで、 GameplayEventData の TargetData から [EMeleeAttackType_Hero] を取得し、 Hero 用の [AttackParameterType] を返しています。


### 方法１

| ファイル名                                        | 分類                | 用途              |
| ------------------------------------------------- | ------------------- | ----------------- |
| [AN_MeleeAttack1HitBox]                           | AnimNotify          | キャラクター共用  |
| [ANS_MeleeAttack1InputPermission]                 | AnimNotifyState     | キャラクター共用  |
| [ANS_MeleeAttack1JumpSection]                     | AnimNotifyState     | キャラクター共用  |
| [AN_MeleeAttack1HitBox_Hero]                      | AnimNotify          | Hero 用           |
| [GA_MeleeAttack1Input]                            | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack1Main]                             | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack1Main_Hero]                        | GameplayAbility     | Hero 用           |
| [AM_Hero_MeleeAttack1]                            | AnimMontage         | Hero 用           |


#### AN_MeleeAttack1HitBox

攻撃判定の発生を [GA_MeleeAttack1Main] 派生クラスに通知する為の AnimNotify です。

* `HasAuthority` を使用して、サーバーのみ処理を行っています。
	* これは攻撃判定はサーバーサイドで実行する想定のためです。
* [GA_MeleeAttack1Main] 派生クラスへの通知は `ApplyHitBoxEventByAttackType` で行います。
	* パラメータとして `GetMeleeAttackType` 関数で取得できる攻撃の種類を渡します。
* 以下の項目はキャラクター毎に異なるため、派生クラスで指定する想定です。
	* `GetMeleeAttackType` （攻撃の種類をを取得するための関数）

#### ANS_MeleeAttack1InputPermission

入力の受付を [GA_MeleeAttack1Main] 派生クラスに通知する為の AnimNotifyState です。

* `IsLocallyControlled` を使用して、自身で操作している Actor のみ処理を行っています。
	* これはこの通知の目的が操作に関することで、レプリケーションする意味がないからです。
* [GA_MeleeAttack1Main] 派生クラスへの通知は `SetInputPermission` で行います。
	* パラメータとして期間の開始時/終了時に true/false をそれぞれ渡します。

#### ANS_MeleeAttack1JumpSection

ジャンプ先のセクション名を [GA_MeleeAttack1Main] 派生クラスに通知する為の AnimNotifyState です。

* 以下はアニメーションモンタージュで指定する想定です。
	* `JumpSectionName`
		* ジャンプ先のセクション名
* `IsLocallyControlled` を使用して、自身で操作している Actor のみ処理を行っています。
	* これはこの通知の目的が操作に関することで、レプリケーションする意味がないからです。
* [GA_MeleeAttack1Main] 派生クラスへの通知は `SetJumpSectionName` で行います。
	* パラメータとして期間の開始時/終了時に `JumpSectionName` で指定された値 / null をそれぞれ渡します。

#### AN_MeleeAttack1HitBox_Hero

[AN_MeleeAttack1HitBox] の派生クラスです。

* Hero 用の設定を行っています。
	* `GetMeleeAttackType` （攻撃の種類をを取得するための関数）
		* アニメーションモンタージュ上で攻撃毎に攻撃の種類を示す [EMeleeAttackType_Hero] を指定できるようにしています。
			* 値の指定はアニメーションモンタージュ [AM_Hero_MeleeAttack1] で行っています。

#### GA_MeleeAttack1Input

入力があったことを GameplayEvent を利用して [GA_MeleeAttack1Main] に通知する GameplayAbility です。

* `Activation Required Tags` で `Loose.MovementMode.Walking` を指定することで、地上にいるときだけ有効化されます。
* `Activation Blocked Tags` で `Loose.Blocks.MeleeAttack1` を指定することで、他の GameplayAbility が MeleeAttack1 の有効化を阻害できるようにしています。
* `Net Execution Policy` で `Local Only` を指定することで、自身で操作している Actor でのみ実行されるようにしています。
* 入力にバインドしてあり、入力時に `ActivateAbility` が呼び出されます。
	* `Send Gameplay Event` で `EventTag` が `Event.MeleeAttack1.Input` の GameplayEvent を発生させます。
	* これにより [GA_MeleeAttack1Main] に入力があったことを通知します。
	* その後、この GameplayAbility は即終了し、次の入力に備えます。

#### GA_MeleeAttack1Main

入力以降の処理を行っている GameplayAbility です。

* `Activation Blocked Tags` で `Loose.Blocks.MeleeAttack1` を指定することで、他の GameplayAbility が MeleeAttack1 の有効化を阻害できるようにしています。
* 入力は `EventTag` に `Event.MeleeAttack1.Input` が指定された GameplayEvent 経由で受け取ります。
	* `Ability Triggers` で `Event.MeleeAttack1.Input` を指定しています。
		* そうすることで、 [GA_MeleeAttack1Main] が有効化されていない場合は `ActivateFromEvent` が呼び出されます。
		* これはサーバーにレプリケーション***されます***。
	* 既に有効化している場合は AbilityTask `Wait Gameplay Event` で `EventTag` が `Event.MeleeAttack1.Input` の GameplayEvent を待っており、 `Event Recieved` ピンに繋がれた処理が実行されます。
		* これはサーバーにレプリケーション***されません***。
	* これらを利用して、初回の入力時にサーバー側の [GA_MeleeAttack1Main] の有効化をしつつ、有効化している間の入力をクライアントサイドのみで処理しています。
* 以下のような処理を行います。
	* アニメーションモンタージュの再生。
	* アニメーションモンタージュのセクションジャンプ。
	* AnimNotify から以下の情報の受け取り。
		* `SetInputPermission` 経由で入力の受け付けフラグ。
		* `ApplyHitBoxEventByAttackType` 経由で攻撃判定発生。
			> note: GameplayEventData
			> 処理内で GameplayEventData を利用しています。
			> これは [ActionRPG] から流用している [MakeEffectContainerSpec] / [ApplyEffectContainerSpec] を利用するためです。 
			> GameplayEvent 自体は使用していません。
			>> 以前は AbilityTask `Wait Gameplay Event` / `Play Montage and Wait Event` を利用して GameplayEvent 経由で攻撃判定情報を受け取っていたので、その名残が残っているという側面もあります。
			>> 今回は GameplayEvent は入力情報のみを受け取るようにし、それ以外は直接関数で受け取るように統一しています。
		* `SetInputPermission` 経由でセクションジャンプの際に利用するセクション名。
	* GameplayTag の付与。（他の GameplayAbility の有効化の阻害用）
		* GameplayAbility が正常に有効化したとき、以下の GameplayTag を Loose に付与します。
			* `Loose.Blocks.Jump` （ジャンプ用）
			* `Loose.Blocks.MeleeAttack2` （ MeleeAttack2 用）
		* これにより、操作が競合する他の GameplayAbility の有効化を阻害しています。
		* Loose に付与している理由は、これらは操作に関連するものであり、レプリケーションする意味がないからでです。
* 以下の項目はキャラクター毎に異なるため、派生クラスで指定する想定です。
	* `Montage` （再生するアニメーションモンタージュ）
	* [EffectContainerMap] の [TargetType]
	* `GetDamageMagnitude` ロジック


#### GA_MeleeAttack1Main_Hero

[GA_MeleeAttack1Main] の派生クラスです。

* Hero 用の設定を行っています。
	* `Montage` （再生するアニメーションモンタージュ）
		* [AM_Hero_MeleeAttack1] を指定。
	* [EffectContainerMap] の [TargetType]
		* [TargetType_MeleeAttack_Hero] を指定。
	* `GetDamageMagnitude` ロジック
		* 攻撃の種類とからダメージ値を取得するための連想配列をメンバで用意しておく。
		* 受け取った GameplayEventData から [EMeleeAttackType_Hero] を取得する。
		* [EMeleeAttackType_Hero] を Key に `DamageMagnitude` を取得し、返却する。


#### AM_Hero_MeleeAttack1

攻撃用のアニメーションモンタージュです。

* Combo1/Combo2/Combo3/Combo4 のセクションを持ちます。
* それぞれのセクション内で３つの AnimNotify を設定しています。
	* [ANS_MeleeAttack1InputPermission]
	* [AN_MeleeAttack1HitBox_Hero]
		* `MeleeAttackTpye`
			* [EMeleeAttackType_Hero] を利用して攻撃の種類を指定しています。
	* [ANS_MeleeAttack1JumpSection]
		* `JumpSectionName`
			* Combo1/Combo2/Combo3/Combo4 の区間でそれぞれ Combo2/Combo3/Combo4/Combo2 を指定しています。
* Combo1 → Combo2 → Combo3 → Combo4 → Combo2 → ... と、終わりがないように指定しているので、ボタンを連打していれば延々にコンボが再生されます。


### 方法２

| ファイル名                                        | 分類                | 用途              |
| ------------------------------------------------- | ------------------- | ----------------- |
| [AN_MeleeAttack2HitBox]                           | AnimNotify          | キャラクター共用  |
| [ANS_MeleeAttack2JumpSection]                     | AnimNotifyState     | キャラクター共用  |
| [AN_MeleeAttack2HitBox_Hero]                      | AnimNotify          | Hero 用           |
| [GA_MeleeAttack2First]                            | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack2Combo]                            | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack2PlayMontage]                      | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack2Damage]                           | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack2JumpSection]                      | GameplayAbility     | キャラクター共用  |
| [GA_MeleeAttack2Damage_Hero]                      | GameplayAbility     | Hero 用           |
| [GA_MeleeAttack2PlayMontage_Hero]                 | GameplayAbility     | Hero 用           |
| [AM_Hero_MeleeAttack2]                            | AnimMontage         | Hero 用           |


#### AN_MeleeAttack2HitBox

攻撃判定の発生を GameplayAbility に通知する為の AnimNotify です。

* 以下はアニメーションモンタージュで指定する想定です。
	* `EventTag`
		* 通知の GameplayEvent で使用する GameplayTag 。
			* 攻撃判定で使用する GameplayEvent 用の GameplayTag を指定します。
			* 攻撃の種類ごとに変更できるよう、指定可能にしています。
* `HasAuthority` を使用して、サーバーのみ処理を行っています。
	* これは攻撃判定はサーバーサイドで実行する想定のためです。
		* なお、 [GA_MeleeAttack2Damage] は `Net Execution Policy` で `Server Only` を指定しているので分岐させなくてもサーバーのみで実行されます。
* GameplayAbility への通知は `Send GameplayEvent to Actor` で行います。
	* イベントタグには `EventTag` で指定された値を使用します。
	* パラメータとして `GetMeleeAttackType` 関数で取得できる攻撃の種類を渡します。
		* これを TargetData に設定した GameplayEventData を生成し、 Payload に設定することで GameplayAbility に渡します。
* 以下の項目はキャラクター毎に異なるため、派生クラスで指定する想定です。
	* `GetMeleeAttackType` （攻撃の種類をを取得するための関数）


#### ANS_MeleeAttack2JumpSection

`次の攻撃に移行可能期間` を GameplayAbility に通知する為の AnimNotify です。

* 以下はアニメーションモンタージュで指定する想定です。
	* `JumpSectionName`
		* ジャンプ先のセクション名。
	* `LooseEnableComboJumpSectionTag`
		* `次の攻撃に移行可能期間` を示す GameplayTag 。
			* この値は監視側と合わせる必要があるため、`Loose.MeleeAttack2.EnableComboJumpSection` をクラス側で指定してます。
* 以下はクラスで固定の値を設定しています。
	* `EventJumpSectionTag`
		* `次の攻撃に移行可能期間` が開始されたことを `Send GameplayEvent to Actor` で通知する際に使用する GameplayTag 。
			* この値は GameplayEvent 待受側と合わせる必要があるため、`Event.MeleeAttack2.Montage.JumpSection` をクラス側で指定してます。
* AnimNotfyState の期間監視用 GameplayTag の付与/削除を行います。
	* AnimNotfyState の期間の開始時/終了時に、`LooseEnableComboJumpSectionTag` で指定された GameplayTag を Loose に付与/削除します。
		* GameplayAbility 内で AbilityTask `Wait Gameplay Tag Remove` を利用して `LooseEnableComboJumpSection` で指定された GameplayTag の監視を行うことで、 AnimNotfyState の期間の監視を行えます。
	* Loose に付与している理由は、これはサーバーのみで処理されるため、レプリケーションする意味がないからでです。
* GameplayAbility への通知は `Send GameplayEvent to Actor` で行います。
	* イベントタグには `EventJumpSectionTag` で指定された値を使用します。
	* パラメータとして `JumpSectionName` で指定された値を渡します。
		* これを TargetData に設定した GameplayEventData を生成し、 Payload に設定することで GameplayAbility に渡します。
* `IsLocallyControlled` を使用して、自身で操作している Actor のみ処理を行っています。
	* これはこの通知の目的が操作に関することで、レプリケーションする意味がないからです。


#### AN_MeleeAttack2HitBox_Hero

[AN_MeleeAttack2HitBox] の派生クラスです。

* Hero 用の設定を行っています。
	* `GetMeleeAttackType` （攻撃の種類をを取得するための関数）
		* アニメーションモンタージュ上で攻撃毎に攻撃の種類を示す [EMeleeAttackType_Hero] を指定できるようにしています。
			* 値の指定はアニメーションモンタージュ [AM_Hero_MeleeAttack1] で行っています。


#### GA_MeleeAttack2First

コンボの一回目の入力を受け取った時に有効化され、アニメーションモンタージュの再生が終わった時に有効化が解除される GameplayAbility です。

* `Activation Required Tags` で `Loose.MovementMode.Walking` を指定することで、地上にいるときだけ有効化されます。
* `Activation Blocked Tags` で `Loose.Blocks.MeleeAttack2` を指定することで、他の GameplayAbility が MeleeAttack2 の有効化を阻害できるようにしています。
* `Net Execution Policy` で `Local Only` を指定することで、自身で操作している Actor でのみ実行されるようにしています。
* 入力にバインドしてあり、入力時に `ActivateAbility` が呼び出されます。
* 以下のような処理を行います。
	* GameplayTag の付与。（他の GameplayAbility の有効化の阻害用）
		* GameplayAbility が正常に有効化したとき、以下の GameplayTag を Loose に付与します。
			* `Loose.Blocks.Jump` （ジャンプ用）
			* `Loose.Blocks.MeleeAttack1` （ MeleeAttack1 用）
		* これにより、操作が競合する他の GameplayAbility の有効化を阻害しています。
		* Loose に付与している理由は、これらは操作に関連するものであり、レプリケーションする意味がないからでです。
	* GameplayTag の付与。（他の GameplayAbility の有効化用）
		* GameplayAbility が正常に有効化したとき、以下の GameplayTag を Loose に付与します。
			* `Loose.MeleeAttack2.RunningFirst` （ [GA_MeleeAttack2First] 実行中判定用）
		* これにより [GA_MeleeAttack2Combo] の有効化の条件を一つ満たします。
			* [GA_MeleeAttack2Combo] は `Activation Required Tags` で `Loose.MeleeAttack2.RunningFirst` を含んでいます。
			* つまり、 [GA_MeleeAttack2First] が有効化中しか [GA_MeleeAttack2Combo] は有効化されません。
		* Loose に付与している理由は、これらは操作に関連するものであり、レプリケーションする意味がないからでです。
	* アニメーションモンタージュの再生終了 GameplayEvent 待ち
		* AbilityTask `Wait Gameplay Event` で `EventTag` が `Event.MeleeAttack2.EndMontage` の GameplayEvent 発生を待ちます。
		* GameplayEvent が発生するまでこの GameplayAbility は有効化のまま待機し、受け取った時点で GameplayAbility を終了します。
	* アニメーションモンタージュの再生 GameplayEvent 呼び出し
		* `Send Gameplay Event` で `EventTag` が `Event.MeleeAttack2.PlayMontage` の GameplayEvent を発生させます。
		* これにより [GA_MeleeAttack2PlayMontage] 派生クラスを有効化します。
	* GameplayAbility 終了時には前述のタスクや Loose に設定していた GameplayTag の削除を行ないます。

#### GA_MeleeAttack2Combo

コンボの入力が可能のときのみ有効化でき、その際に入力があったことを示す GameplayTag `Loose.MeleeAttack2.PushedCombo` を付与する GameplayAbility です。

* `Activation Required Tags` で有効化の制限を行っています。
	* `Loose.MovementMode.Walking` を指定することで、地上にいるときだけ有効化されます。
	* `Loose.MeleeAttack2.RunningFirst` を指定することで、 [GA_MeleeAttack2First] が有効化しているときだけ有効化されます。
	* `Loose.MeleeAttack2.EnableComboInput` を指定することで、 [AM_Hero_MeleeAttack2] で入力を許可している期間だけ有効化されます。
* `Activation Blocked Tags` で有効化の制限を行っています。
	* `Loose.Blocks.MeleeAttack2` を指定することで、他の GameplayAbility が MeleeAttack2 の有効化を阻害できるようにしています。
	* `Loose.MeleeAttack2.PushedCombo` を指定することで、コンボ入力が既に行われている場合は有効化を阻害するようにしています。
* `Net Execution Policy` で `Local Only` を指定することで、自身で操作している Actor でのみ実行されるようにしています。
* 入力にバインドしてあり、入力時に `ActivateAbility` が呼び出されます。
* 以下のような処理を行います。
	* GameplayTag の付与。（入力フラグ用）
		* GameplayAbility が正常に有効化したとき、以下の GameplayTag を Loose に付与します。
			* `Loose.MeleeAttack2.PushedCombo`
		* これを行うのは一回だけで、既に付与されている場合は処理を行いません。
			* `Activation Blocked Tags` で同タグの指定をすることで GameplayAbility の有効化自体を防いでいます。
		* このタグにより、「地上で」「コンボ用のアニメーションモンタージュが再生中で」「コンボの入力許可期間」に入力があったことがわかります。
		* Loose に付与している理由は、これらは操作に関連するものであり、レプリケーションする意味がないからでです。

#### GA_MeleeAttack2PlayMontage

アニメーションモンタージュの再生を行い、再生終了時に GameplayEvent 呼び出しを行う GameplayAbility です。

* 有効化は `EventTag` が `Event.MeleeAttack2.PlayMontage` の GameplayEvent 経由で行われます。
	* `Ability Triggers` で `Event.MeleeAttack2.PlayMontage` を指定しています。
		* そうすることで、 [GA_MeleeAttack2PlayMontage] が有効化されていない場合は `ActivateFromEvent` が呼び出されます。
		* これはサーバーにレプリケーション***されます***。
* 以下のような処理を行います。
	* アニメーションモンタージュの再生
		* GameplayAbility が正常に有効化したとき、 AbilityTask `PlayMontageAndWait` でアニメーションモンタージュを再生し、その終了を待ちます。
		* アニメーションモンタージュが終了したら GameplayAbility を終了します。
	* `IsLocallyControlled` を使用して、自身で操作している Actor のみ以下の処理を行います。
		* アニメーションモンタージュの再生終了 GameplayEvent 呼び出し
			* `Send Gameplay Event` で `EventTag` が `Event.MeleeAttack2.EndMontage` の GameplayEvent を発生させます。
			* これにより [GA_MeleeAttack2First] にアニメーションモンタージュ再生の終了を知らせます。
* 以下の項目はキャラクター毎に異なるため、派生クラスで指定する想定です。
	* `Montage` （再生するアニメーションモンタージュ）

#### GA_MeleeAttack2Damage

サーバーのみ呼び出される、攻撃判定処理を行う GameplayAbility です。

* `Net Execution Policy` で `Sever Only` を指定することで、サーバーでのみ実行されるようにしています。
* 有効化は `EventTag` が `Event.MeleeAttack2.Montage.SphereTrace` の GameplayEvent 経由で行われます。
	* `Ability Triggers` で `Event.MeleeAttack2.Montage.SphereTrace` を指定しています。
		* そうすることで、 [GA_MeleeAttack2Damage] が有効化されていない場合は `ActivateFromEvent` が呼び出されます。
		* この GameplayEvent は [AN_MeleeAttack2HitBox] で `Send Gameplay Event to Actor` で呼び出されます。
* 以下の項目はキャラクター毎に異なるため、派生クラスで指定する想定です。
	* [EffectContainerMap] の [TargetType]
	* `GetDamageMagnitude` ロジック

#### GA_MeleeAttack2JumpSection

クライアントのみで呼び出される、セクションジャンプを行う GameplayAbility です。
サーバーへは [CurrentMontageJumpToSection] 内の RPC 呼び出しにより同期が行われます。

* `Net Execution Policy` で `Local Only` を指定することで、自身で操作している Actor でのみ実行されるようにしています。
* 有効化は `EventTag` が `Event.MeleeAttack2.Montage.JumpSection` の GameplayEvent 経由で行われます。
	* `Ability Triggers` で `Event.MeleeAttack2.Montage.JumpSection` を指定しています。
		* そうすることで、 [GA_MeleeAttack2JumpSection] が有効化されていない場合は `ActivateFromEvent` が呼び出されます。
		* これは（ `Net Execution Policy` により）サーバーにレプリケーション***されません***。
* 以下のような処理を行います。
	* `次の攻撃に移行可能期間` の監視
		* `Loose.MeleeAttack2.EnableComboJumpSection` の付与状況を監視し、削除されたら GameplayAbility を終了します。
			* これにより、 `次の攻撃に移行可能期間` のみ入力を受け付けています。
	* 入力状況の監視
		* `Loose.MeleeAttack2.PushedCombo` の付与状況を監視し、付与されたら [CurrentMontageJumpToSection] を呼び出した後に GameplayAbility を終了します。
	* GameplayAbility 終了時には `Loose.MeleeAttack2.PushedCombo` の削除を行ないます。


#### GA_MeleeAttack2PlayMontage_Hero

[GA_MeleeAttack2PlayMontage] の派生クラスです。

* Hero 用の設定を行っています。
	* `Montage` （再生するアニメーションモンタージュ）
		* [AM_Hero_MeleeAttack2] を指定。


#### GA_MeleeAttack2Damage_Hero

[GA_MeleeAttack2Damage] の派生クラスです。

* Hero 用の設定を行っています。
	* [EffectContainerMap] の [TargetType]
		* [TargetType_MeleeAttack_Hero] を指定。
	* `GetDamageMagnitude` ロジック
		* 攻撃の種類とからダメージ値を取得するための連想配列をメンバで用意しておく。
		* 受け取った GameplayEventData から [EMeleeAttackType_Hero] を取得する。
		* [EMeleeAttackType_Hero] を Key に `DamageMagnitude` を取得し、返却する。


#### AM_Hero_MeleeAttack2

攻撃用のアニメーションモンタージュです。

* Combo1/Combo2/Combo3/Combo4 のセクションを持ちます。
* それぞれのセクション内で３つの AnimNotify を設定しています。
	* [ANS_AddLooseGameplayTagsIfOwnerLocallyControlled]
		* `GameplayTag`
			* `Loose.MeleeAttack2.EnableComboInput` を指定しています。
			* これにより、この AnimNotifyState の期間中、 [GA_MeleeAttack2Combo] の有効化の条件を一つ満たします。
				* [GA_MeleeAttack2Combo] は `Activation Required Tags` で `Loose.MeleeAttack2.EnableComboInput` を含んでいます。
				* つまり、 この AnimNotifyState の期間中しか [GA_MeleeAttack2Combo] は有効化されません。
	* [AN_MeleeAttack2HitBox_Hero]
		* `MeleeAttackTpye` 
			* [EMeleeAttackType_Hero] を利用して攻撃の種類を指定しています。
		* `EventTag`
			* `Event.MeleeAttack2.Montage.SphereTrace` を指定しています。
				* これにより [GA_MeleeAttack2Damage] クラスを有効化します。
				* 攻撃の種類ごとに変更できるように指定可能にしていますが、今回はこの値しか使用していません。
	* [ANS_MeleeAttack2JumpSection]
		* `JumpSectionName` 
			* Combo1/Combo2/Combo3/Combo4 の区間でそれぞれ Combo2/Combo3/Combo4/Combo2 を指定しています。
		* `LooseEnableComboJumpSectionTag`
			* `Loose.MeleeAttack2.EnableComboJumpSection` を指定しています。（クラスで指定した値そのままです）
				* これにより、 [GA_MeleeAttack2JumpSection] の AbilityTask `Wait Gameplay Tag Remove` で AnimNotfyState の期間の監視を行えます。
* Combo1 → Combo2 → Combo3 → Combo4 → Combo2 → ... と、終わりがないように指定しているので、ボタンを連打していれば延々にコンボが再生されます。


----

以上で、 二種類の方法で攻撃を実装することができます。

-----
おしまい。

[方法](#方法)
[大要](#大要)

[EffectContainerMap]: #effectcontainermap
[FGHOGameplayEffectContainer]: #fghogameplayeffectcontainer
[EffectContainer]: #fghogameplayeffectcontainer
[UGHOTargetType]: #ughotargettype
[TargetType]: #ughotargettype
[MakeEffectContainerSpec]: #makeeffectcontainerspec
[ApplyEffectContainerSpec]: #applyeffectcontainerspec
[FindAbilitySpecFromClassWithAllowInheritedTypeFlag]: #findabilityspecfromclasswithallowinheritedtypeflag
[GetPrimaryAbilityInstanceFromClass]: #getprimaryabilityinstancefromclass
[CurrentMontageJumpToSection]: #currentmontagejumptosection
[UGHOHitResultFilterType]: #ughohitresultfiltertype
[HitResultFilterType]: #ughohitresultfiltertype
[FGameplayAbilityTargetData_Int32]: #fgameplayabilitytargetdata_int32
[FGameplayAbilityTargetData_Name]: #fgameplayabilitytargetdata_name
[UGHOBlueprintFunctionLibrary]: #ughoblueprintfunctionlibrary

[ANS_AddLooseGameplayTagsIfOwnerLocallyControlled]: #ans_addloosegameplaytagsifownerlocallycontrolled
[GA_MovementMode]: #ga_movementmode
[GA_CharacterJump]: #ga_characterjump
[AttackParameterType]: #attackparametertype
[GE_MeleeAttackDamage]: #ge_meleeattackdamage
[TargetType_SphereTrace]: #targettype_spheretrace
[HitResultFilterType_Nearest]: #hitresultfiltertype_nearest
[EMeleeAttackType_Hero]: #emeleeattacktype_hero
[TargetType_MeleeAttack_Hero]: #targettype_meleeattack_hero
[AN_MeleeAttack1HitBox]: #an_meleeattack1hitbox
[ANS_MeleeAttack1InputPermission]: #ans_meleeattack1inputpermission
[ANS_MeleeAttack1JumpSection]: #ans_meleeattack1jumpsection
[AN_MeleeAttack1HitBox_Hero]: #an_meleeattack1hitbox_hero
[GA_MeleeAttack1Input]: #ga_meleeattack1input
[GA_MeleeAttack1Main]: #ga_meleeattack1main
[GA_MeleeAttack1Main_Hero]: #ga_meleeattack1main_hero
[AM_Hero_MeleeAttack1]: #am_hero_meleeattack1
[AN_MeleeAttack2HitBox]: #an_meleeattack2hitbox
[ANS_MeleeAttack2JumpSection]: #ans_meleeattack2jumpsection
[AN_MeleeAttack2HitBox_Hero]: #an_meleeattack2hitbox_hero
[GA_MeleeAttack2First]: #ga_meleeattack2first
[GA_MeleeAttack2Combo]: #ga_meleeattack2combo
[GA_MeleeAttack2PlayMontage]: #ga_meleeattack2playmontage
[GA_MeleeAttack2Damage]: #ga_meleeattack2damage
[GA_MeleeAttack2JumpSection]: #ga_meleeattack2jumpsection
[GA_MeleeAttack2PlayMontage_Hero]: #ga_meleeattack2playmontage_hero
[GA_MeleeAttack2Damage_Hero]: #ga_meleeattack2damage_hero
[AM_Hero_MeleeAttack2]: #am_hero_meleeattack2

[ActionRPG]: https://www.unrealengine.com/marketplace/ja/product/action-rpg
[GASDocumentation]: https://github.com/tranek/GASDocumentation
[GASDocumentation 和訳]: https://github.com/sentyaanko/GASDocumentation/blob/lang-ja/README.jp.md
[GASShooter]: https://github.com/tranek/GASShooter
[GASShooter 和訳]: https://github.com/sentyaanko/GASShooter/blob/lang-ja/README.jp.md
[GAS Companion]: https://www.unrealengine.com/marketplace/ja/product/gas-companion

